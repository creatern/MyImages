# 前导

## 时间复杂度的计算

**常见的时间复杂度**



**最好情况、最坏情况、平均情况**



# 数据结构

## 线性表

**线性结构**

- 数组、队列、链表、栈
- 数据元素之间存在一对一的线性关系

|       顺序表(数组)        |                   链表                    |
| :----------------------: | :--------------------------------------: |
|         顺序存储          |                 链式存储                  |
| 顺序表中的存储元素是连续的 |       链表中的存储元素不一定是连续的        |
|            -             | 元素节点中存放数据元素以及相邻元素的地址信息 |

**非线性结构**

- 二维数组，多维数组，广义表，树结构，图结构

**顺序表 顺序存储结构**

- 使用一维数组

### 队列

- 有序列表
- 先入先出的原则

#### 数组实现队列

![](c:/notebook/pictures/Snipaste_2022-11-24_22-14-06.png =600x)

![](c:/notebook/pictures/Snipaste_2022-11-26_23-50-38.png =400x)

- 该为一次性的，其rear、front属性的增长没有可逆的。

```java
package com.study01;

import java.util.Scanner;

public class ArrayQueueDemo {
	public static void main(String[] args) {
		ArrayQueue arrQueue = new ArrayQueue(3);
		char key = ' '; // 接受用户输入
		Scanner scan = new Scanner(System.in);
		boolean loop = true;
		// 菜单
		while (loop) {
			System.out.println("------菜单------");
			System.out.println("s(show)");
			System.out.println("e(exit)");
			System.out.println("a(add)");
			System.out.println("g(get)");
			System.out.println("h(head)");
			System.out.println("请选择：");

			key = scan.next().charAt(0);

			try {
				switch (key) {
				case 's':
					arrQueue.showQueue();
					break;
				case 'e':
					loop = false;
					break;
				case 'a':
					System.out.println("输入要添加的值：");
					int value = scan.nextInt();
					arrQueue.addQueue(value);
					break;
				case 'g':
					arrQueue.getQueue();
					break;
				case 'h':
					arrQueue.headQueue();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		System.out.println("已退出！！！");
	}
}

//使用数组模拟队列
class ArrayQueue {
	private int maxSize; // 表示数组的最大容量
	private int front; // 队列头
	private int rear; // 队列尾
	private int[] arr; // 模拟队列

	// 创建队列的构造器
	public ArrayQueue(int maxSize) {
		this.maxSize = maxSize;
		arr = new int[maxSize];
		front = -1; // 指向队列头的前一个位置
		rear = -1; // 指向队列最后一个数据
	}

	// 判断队列是否满
	public boolean isFull() {
		return rear == maxSize - 1;
	}

	// 判断队列是否为空
	public boolean isEmpty() {
		return rear == front;
	}

	// 添加数据到队列
	public void addQueue(int value) {
		if (isFull()) {
			System.out.println("队列满！！！");
			return;
		}
		rear++; // rear后移
		arr[rear] = value;
	}

	// 获取队列的数据，出队列
	public int getQueue() {
		// 判断队列是否空
		if (isEmpty()) {
			// 通过抛出异常
			throw new RuntimeException("队列为空");
		}
		// front后移
		return arr[++front];
	}

	// 遍历
	public void showQueue() {
		if (isEmpty()) {
			System.out.println("队列空！！！");
			return;
		}
		for (int i : arr) {
			System.out.printf("arr[%d]=%d\n", i, arr[i]);
		}
	}

	// 显示队列的头，并不取出
	public int headQueue() {
		if (isEmpty()) {
			throw new RuntimeException("队列空！！！");
		}
		return arr[front];
	}
}
```

#### 数组模拟环形队列

![](c:/notebook/pictures/Snipaste_2022-11-26_23-58-17.png =800x)

- 主要通过对rear和front的取模操作，实现循环增长
   - `rear = (rear + 1) % maxSize;`
   - `front = (front + 1) % maxSize;`

```java
package com.study01;

import java.util.Scanner;

public class CircleArrayQueueDemo {
	public static void main(String[] args) {
		CircleArrayQueue arrQueue = new CircleArrayQueue(3);
		char key = ' '; // 接受用户输入
		Scanner scan = new Scanner(System.in);
		boolean loop = true;
		// 菜单
		while (loop) {
			System.out.println("------菜单------");
			System.out.println("s(show)");
			System.out.println("e(exit)");
			System.out.println("a(add)");
			System.out.println("g(get)");
			System.out.println("h(head)");
			System.out.println("请选择：");

			key = scan.next().charAt(0);

			try {
				switch (key) {
				case 's':
					arrQueue.showQueue();
					break;
				case 'e':
					loop = false;
					break;
				case 'a':
					System.out.println("输入要添加的值：");
					int value = scan.nextInt();
					arrQueue.addQueue(value);
					break;
				case 'g':
					arrQueue.getQueue();
					break;
				case 'h':
					arrQueue.headQueue();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		System.out.println("已退出！！！");
	}
}

//使用数组模拟队列
class CircleArrayQueue {
	private int maxSize; // 表示数组的最大容量
	private int front; // 队列头
	private int rear; // 队列尾
	private int[] arr; // 模拟队列

	// 创建队列的构造器
	public CircleArrayQueue(int maxSize) {
		this.maxSize = maxSize;
		arr = new int[maxSize];
		// front 、rear 默认0
	}

	// 判断队列是否满
	public boolean isFull() {
		return (rear + 1) % maxSize == front;
	}

	// 判断队列是否为空
	public boolean isEmpty() {
		return rear == front;
	}

	// 添加数据到队列
	public void addQueue(int value) {
		if (isFull()) {
			System.out.println("队列满！！！");
			return;
		}
		arr[rear] = value;
		// 将rear后移 考虑取模，防止数组越界
		rear = (rear + 1) % maxSize;
	}

	// 获取队列的数据，出队列
	public int getQueue() {
		// 判断队列是否空
		if (isEmpty()) {
			// 通过抛出异常
			throw new RuntimeException("队列为空");
		}
		int value = arr[front];
		// front 后移
		front = (front + 1) % maxSize;
		return value;
	}

	// 遍历 从front开始遍历
	public void showQueue() {
		if (isEmpty()) {
			System.out.println("队列空！！！");
			return;
		}

		// 求出当前队列有序数据的个数 (rear + maxSize -front) % maxSize
		// 在经过多次使用后，front的值很可能以及超过maxSize，所以需要取模 int i = front % maxSize
		for (int i = front % maxSize; i < front + ((rear + maxSize - front) % maxSize); i++) {
			System.out.printf("arr[%d]=%d\n", i, arr[i]);
		}
	}

	// 显示队列的头，并不取出
	public int headQueue() {
		if (isEmpty()) {
			throw new RuntimeException("队列空！！！");
		}
		return arr[front];
	}
}
```

#### 链表实现队列

- 无序添加的单向链表

### 链表

- 链表以节点的方式存储，是链式存储
- 链表的每个节点包含data域，<mark>next域：指向下一个节点</mark>
- 链表的各个节点不一定是连续存储

桥梁设计模式的思想

#### 单向链表

1. 无序添加
![](c:/notebook/pictures/Snipaste_2022-11-29_23-34-01.png =700x)
2. 有序添加
![](c:/notebook/pictures/Snipaste_2022-11-29_23-34-54.png =700x)
3. 删除
![](c:/notebook/pictures/Snipaste_2022-11-30_00-51-38.png =700x)

```java
package com.SingleLinkedList;

public class SingleLinkedListDemo {
	public static void main(String[] args) {
		// 无序添加测试
		SingleLinkedList singleLinkedList = new SingleLinkedList();
		singleLinkedList.list();
		singleLinkedList.add(new HeroNode(1, "宋江", "及时雨"));
		singleLinkedList.add(new HeroNode(5, "鲁智深", "花和尚"));
		singleLinkedList.add(new HeroNode(6, "柴进", "小旋风"));
		singleLinkedList.add(new HeroNode(4, "李逵", "黑旋风"));
		singleLinkedList.add(new HeroNode(2, "杨志", "青面兽"));
		singleLinkedList.list();

		// 有序添加测试
		SingleLinkedList singleLinkedList2 = new SingleLinkedList();
		singleLinkedList2.list();
		singleLinkedList2.addByOrder(new HeroNode(1, "宋江", "及时雨"));
		singleLinkedList2.addByOrder(new HeroNode(5, "鲁智深", "花和尚"));
		singleLinkedList2.addByOrder(new HeroNode(2, "柴进", "小旋风"));
		singleLinkedList2.addByOrder(new HeroNode(4, "李逵", "黑旋风"));
		singleLinkedList2.addByOrder(new HeroNode(7, "杨志", "青面兽"));
		singleLinkedList2.list();

		// 修改测试
		singleLinkedList2.update(new HeroNode(4, "西瓜", "喝的"));
		singleLinkedList2.update(new HeroNode(6, "香蕉", "吃的"));
		singleLinkedList2.list();

		// 删除测试
		singleLinkedList2.delete(4);
		singleLinkedList2.delete(0);
		singleLinkedList2.delete(1);
		singleLinkedList2.list();
	}

}

//定义SingleLinkedList 进行管理HeroNode
class SingleLinkedList {
	// 先初始化一个头节点，不存放具体的数据
	// head不能改变
	private final HeroNode head = new HeroNode(0, "", "");

	// 添加一个数据到单向链表
	// 当不考虑编号的顺序时：
	// 1. 找到当前链表的最后节点
	// 2. 将最后节点的next域指向新的节点
	public void add(HeroNode heroNode) {
		HeroNode temp = head;
		// 遍历链表，使temp指向最后的节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			// 如果没有找到最后，则将temp后移一位
			temp = temp.next;
		}
		// 使最后一个节点的next指向新的节点
		temp.next = heroNode;
	}

	// 显示链表 遍历
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表null");
			return;
		}
		HeroNode temp = head.next;
		while (true) {
			// 判断是否到链表最后
			if (temp == null) {
				break;
			}
			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移一位
			temp = temp.next;
		}
	}

	// 有序添加
	// 根据排名no 插入到指定的排名（位置）
	// 如果有这个no则添加失败
	public void addByOrder(HeroNode heroNode) {
		// 由单向链表的特性：temp是位于添加位置的前一个节点，否则插入失败
		HeroNode temp = head;
		boolean flag = false; // flag标志添加的编号是否存在，默认为false；
		while (true) {
			if (temp.next == null) { // 表明temp已经到链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) { // 如果找到合适的排名no
				break;
			} else if (temp.next.no == heroNode.no) { // 如果要插入的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next; // temp后移一位
		}
		if (flag) { // 判断能否插入
			System.out.println("待插入的用户的编号已经存在！插入失败\n" + heroNode.no);
			return;
		}
		// 插入到链表中，temp的后面
		heroNode.next = temp.next;
		temp.next = heroNode;
	}

	// 修改节点的信息，根据编号排名no来修改（该属性不能修改）
	public void update(HeroNode heroNode) {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表null");
			return;
		}
		HeroNode temp = head.next;
		boolean flag = false; // 判断是否找到该节点
		while (true) {
			if (temp == null) { // 达到链表的末尾
				break;
			}
			if (temp.no == heroNode.no) { // 找到对应的排名no
				flag = true;
				break;
			}
			temp = temp.next;
		}
		// 根据flag 判断是否找到要修改的节点
		if (flag) {
			temp.name = heroNode.name;
			temp.nickName = heroNode.nickName;
		} else {
			System.out.printf("未找到当前节点%d", heroNode.no);
		}
	}

	// 删除节点
	// 1. head节点不能改变，需要temp节点找到带删除节点的前一个节点
	// 2. 在比较时，是temp.next.no和需要删除节点heroNode.no比较
	public void delete(int no) {
		HeroNode temp = head;
		boolean flag = false; // 是否找到待删除节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) { // 找到待删除节点
				flag = true;
				break;
			}
			temp = temp.next;
		}
		// 判断flag
		if (flag) { // 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.println("要删除的节点不存在");
		}
	}
}

//定义HeroNode 每个HeroNode的对象就是一个节点
class HeroNode {
	// data域
	public int no;
	public String name;
	public String nickName;
	// next域
	public HeroNode next;

	public HeroNode(int no, String name, String nickName) {
		this.no = no;
		this.name = name;
		this.nickName = nickName;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickName=" + nickName + "]";
	}
}
```

##### 例题

![](c:/notebook/pictures/Snipaste_2022-11-30_21-07-21.png =600x)

![](C:/notebook/pictures/Snipaste_2022-11-30_23-51-34.png =600x)
![](c:/notebook/pictures/Snipaste_2022-12-01_00-15-14.png =600x)

![](c:/notebook/pictures/Snipaste_2022-12-01_00-28-20.png =300x)

```java
public class SingleLinkedListDemo2 {

    public static void main(String[] args) {
        StudentSingleLinkedList list = new StudentSingleLinkedList();
        list.list();
        list.add(new StudentNode(1, "Tom"));
        list.add(new StudentNode(2, "Jac"));
        list.add(new StudentNode(5, "Mac"));
        list.add(new StudentNode(3, "King"));
        list.list();

        // 1.
        System.out.println(list.count(list.getHead()));

        // 2.
        System.out.println(list.findCountdown(list.getHead(), 1));
        System.out.println(list.findCountdown(list.getHead(), 4));
        System.out.println(list.findCountdown(list.getHead(), 0));

        StudentSingleLinkedList list2 = new StudentSingleLinkedList();
        list2.add(new StudentNode(5, "小米"));
        list2.add(new StudentNode(7, "正则"));
        list2.union(list);
        list2.list();

        list2.reverse(list2.getHead());
        list2.list();
    }
}

class StudentSingleLinkedList {
    private final StudentNode head = new StudentNode(0, "");

    public StudentNode getHead() {
        return head;
    }

    // 有序添加
    public void add(StudentNode studentNode) {
        StudentNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > studentNode.no) {
                break;
            } else if (temp.next.no == studentNode.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            System.out.println("插入的数据已存在");
            return;
        }
        studentNode.next = temp.next;
        temp.next = studentNode;
    }

    // 遍历
    public void list() {
        if (head.next == null) {
            System.out.println("null");
            return;
        }
        StudentNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }

    // 1.求单链表中有效节点的个数
    // 不统计head
    public int count(StudentNode head) {
        if (head.next == null) {
            return 0;
        }
        StudentNode temp = head.next;
        int counters = 1; // 包含当前的temp
        while (true) {
            if (temp.next == null) {
                break;
            }
            counters++;
            temp = temp.next;
        }
        return counters;
    }

    // 2. 查找单链表中的倒数第k个节点
    public StudentNode findCountdown(StudentNode head, int k) {
        if (head.next == null) {
            System.out.println("null");
            return null;
        }

        int check = count(head);
        if (k <= 0 || k > check) {
            System.out.println("无此节点");
            return null;
        }
        check = check - k;
        StudentNode temp = head.next;
        for (int i = 1; i < check; i++) {
            temp = temp.next;
        }
        return temp;

//		int n = 1;
//		while (true) {
//			if (n == check) {
//				return temp;
//			}
//			n++;
//			temp = temp.next;
//		}
    }

    // 3.单链表的反转
    public void reverse(StudentNode head) {
        //如果当前链表为空或只有一个节点，则跳过反转
        if (head.next == null || head.next.next == null) {
            return;
        }
        //辅助指针：遍历原来的链表
        StudentNode cur = head.next;
        //指向当前节点cur的下一个点
        StudentNode next = null;

        StudentNode reverseHead = new StudentNode(0, "");

        //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
        while (cur != null) {
            next = cur.next; //先暂存当前节点下一个节点
            cur.next = reverseHead.next; //将cur的下一个节点指向新的链表的最前端
            reverseHead.next = cur;
            cur = next;//后移一位
        }
        //将head.next指向reverseHead.next 实现链表的反转
        head.next = reverseHead.next;
    }

    // 4.逆序打印单链表
    public void print(StudentNode head){

    }

    // 5.合并两个有序的单链表
    public void union(StudentSingleLinkedList list) {
        StudentNode value = list.getHead().next;
        while (value != null) {
            StudentNode temp = new StudentNode(value.no, value.name);
            temp.next = value.next;
            this.add(temp);
            value = value.next;
        }
    }
}

class StudentNode {
    protected int no;
    protected String name;
    protected StudentNode next;

    public StudentNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "StudentNode [no=" + no + ", name=" + name + "]";
    }
}
```

#### 双向链表

- 在单向链表的基础上添加了一个pre域，用于存放前一个节点，实现向前或向后的增删改查。
- 双向链表可以实现当前节点的自我删除，而单向链表需要上一个节点的配合才能实现删除当前节点。

![](c:/notebook/pictures/Snipaste_2022-12-11_15-31-51.png =850x)

```java
package linkedList;

public class BidirectionalLinkedListDemo {
    public static void main(String[] args) {
        BidirectionalLinkedList list = new BidirectionalLinkedList();
        list.addByOrder(new Node(1, "Tom"));
        list.addByOrder(new Node(3, "Jac"));
        list.addByOrder(new Node(2, "Mac"));
        list.addByOrder(new Node(5, "Tik"));
        list.tailAdd(new Node(4, "Last"));
        list.show();

        list.update(new Node(3, "King"));
        list.update(new Node(4, "Test"));
        list.show();

        list.delete(3);
        list.show();
    }
}


class BidirectionalLinkedList {
    private Node head = new Node(0, " ");

    //有序添加
    public void addByOrder(Node newNode) {
        //判断链表是否空
        if (head.next == null) {
            head.next = newNode;
            newNode.pre = head;
            return;
        }
        Node current = head; //当前节点
        boolean isExist = false; //判断是否存在
        while (true) {
            if (current.next == null) { //到达链表尾部
                break;
            } else if (current.next.no == newNode.no) { //如果已经存在
                isExist = true;
                break;
            } else if (current.next.no > newNode.no) { //找到合适的位置
                break;
            }
            current = current.next;
        }
        if (isExist) { //如果已经存在
            System.out.println("该节点已经存在");
            return;
        }
        //添加
        newNode.next = current.next;
        newNode.pre = current;
        if (current.next != null) { //如果current的next不为null
            current.next.pre = newNode;
        }
        current.next = newNode;
    }

    //尾部追加
    public void tailAdd(Node newNode) {
        //先找最后一个节点
        Node current = head;
        while (true) {
            if (current.next == null) {
                break;
            }
            current = current.next;
        }
        //添加操作
        current.next = newNode;
        newNode.pre = current;
    }

    //遍历
    public void show() {
        if (head.next == null) { //判断链表是否空
            System.out.println("null");
            return;
        }

        Node current = head.next;
        while (true) {
            System.out.println(current);
            if ((current = current.next) == null) {
                break;
            }
        }
    }

    //更新 根据no来更新
    public void update(Node newNode) {
        if (head.next == null) { //判断链表是否空
            System.out.println("null");
            return;
        }

        Node current = head.next;
        boolean isExist = false; //判断是否存在匹配的节点
        while (true) {
            if (current == null) { //到达链表尾部
                break;
            }
            if (current.no == newNode.no) {
                isExist = true;
                break;
            }
            current = current.next;
        }
        //更新操作
        if (isExist) {
            current.name = newNode.name;
            System.out.println("Updated !");
        } else {
            System.out.println("not find");
        }
    }

    //删除 按照no来删除
    public void delete(int no) {
        if (head == null) { //判断链表是否空
            System.out.println("null");
            return;
        }

        Node current = head.next;
        boolean isExist = false;
        while (true) {
            if (current == null) {//到达链表尾部
                break;
            } else if (current.no == no) {
                isExist = true;
                break;
            }
            current = current.next;
        }
        if (isExist) {
        //自我删除
            if (current.next != null) { //判断current的next是否为null
                current.next.pre = current.pre;
            }
            current.pre.next = current.next;
            System.out.println("Deleted !");
        } else {
            System.out.println("not find");
        }
    }
}

class Node {
    protected int no;
    protected String name;

    protected Node pre; //指向前一个节点
    protected Node next; //指向后一个节点

    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "no=" + no + "\tname=" + name;
    }
}
```

#### 单向环形链表 （约瑟夫环）

**Josephu(约瑟夫、约瑟夫环)  问题**

- Josephu  问题为：设编号为1，2，… ，n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
- 用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。

![](c:/notebook/pictures/Snipaste_2022-12-11_15-48-35.png =600x)

1. 在第一次添加时，用第一个节点就替代head头节点。
2. 将单链表的最后一个节点的next指向第一个节点。
3. 环形链表中只有一个节点的时候停止返回，即node.next=node的时候。
4. 计数时，可以使用取余等操作避免不必要的循环。注意：走的次数是否越界。

```java
package linkedList;

public class Josephu {
    public static void main(String[] args) {
        RingLinkedList list = new RingLinkedList();
        list.count(10, 0, 40);
    }
}

class RingLinkedList {
    protected RingNode first;
    int number; //用于遍历

    //创建环型链表
    public RingNode create(int number) {
        if (number < 1) { //判断是否合法
            throw new RuntimeException("输入的个数不合法");
        }
        first = new RingNode(0);
        RingNode temp = first;
        for (int i = 1; i < number; i++) {
            temp.next = new RingNode(i);
            temp = temp.next;
        }
        //形成闭环
        temp.next = first;

        //用于遍历
        this.number = number;
        return temp;
    }

    //计数
    public void count(int createNumber, int startIndex, int countNumber) {
        //判断创建的节点数量和开始的计数是否合法
        if (startIndex > createNumber - 1) {
            System.out.println("开始的节点位置" + startIndex + "大于所有节点的数量" + createNumber);
            return;
        }

        //创建链表
        //获得当前节点的前一位，以用来作为删除节点的前一位
        RingNode preNode = this.create(createNumber);
        //获得开始的节点
        RingNode current = first;
        for (int i = 0; i < startIndex; i++) {
            preNode = current;
            current = current.next;
        }


        int curCount; //记录每次的取余的计数，优化。
        int nodeNumber = createNumber; //记录当前的剩余节点数，优化。
        //开始计数
        while (current.next != current) {
            curCount = countNumber % nodeNumber--;
            for (int i = 0; i < curCount; i++) {
                preNode = current;
                current = current.next;
            }
            //删除当前节点
            System.out.println("删除的节点：" + current);
            preNode.next = current.next;
            //还给原先被删除节点的下一位
            current = preNode.next;
        }
        System.out.println("最后一位: " + current);
    }
}

class RingNode {
    protected int no;
    protected RingNode next;

    public RingNode(int no) {
        this.no = no;
    }

    @Override
    public String toString() {
        return "RingNode{" +
                "no=" + no +
                '}';
    }
}
```

#### 静态链表和动态链表

- 静态链表：使用数组存放链表
- 动态链表：额外创建expend()方法，动态扩展数组长度

```java
package linkedList;

public class StaticLinkDemo {
    public static void main(String[] args) {
        StaticLink staticLink = new StaticLink();

        staticLink.add(new StaticLinkNode(8));
        staticLink.add(new StaticLinkNode(3));
        staticLink.add(new StaticLinkNode(6));
        staticLink.add(new StaticLinkNode(4));
        staticLink.prinkLink();
    }
}

class StaticLink {
    StaticLinkNode[] link = null; //储存静态链表数组
    int curFree = 1; //当前空闲的位置
    int avail = 0; //0下标空闲
    int MAX_LENGTH = 8;

    //创建
    public StaticLink() {
        link = new StaticLinkNode[MAX_LENGTH];
    }

    public StaticLink(int length) {
        MAX_LENGTH = length;
        link = new StaticLinkNode[MAX_LENGTH];
    }

    //添加
    public void add(StaticLinkNode node) {
        //如果link的长度到达最大值，则扩展1倍长度
        if (curFree > link.length - 1) {
            extend();
        }
        node.setNext(curFree); //设置node的下一个结点
        link[curFree++] = node;
    }

    //扩展
    public void extend() {
        MAX_LENGTH *= 2;
        StaticLinkNode[] tempLink = new StaticLinkNode[MAX_LENGTH];
        System.arraycopy(tempLink, 0, link, 0, link.length);
        link = tempLink;
    }

    //打印
    public void prinkLink() {
        for (int i = 1; i < curFree; i++) {
            System.out.print(link[i] + ",");
        }
    }
}

class StaticLinkNode {
    int value;
    int next;

    public StaticLinkNode(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getNext() {
        return next;
    }

    public void setNext(int next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "StaticLinkNode{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}
```

```java
package linkedList;

import java.util.LinkedList;

public class StaticLinkedListDemo {
    public static void main(String[] args) {
        StaticLinkedList listA = new StaticLinkedList();
        int la[] = {
                2, 3, 5, 8, 9, 6, 7
        };
        for (int i = 0; i < la.length; i++) {
            listA.add(la[i]);
        }
        listA.delete(6);
        listA.delete(0);

        listA.insert(3, 88);
        listA.insert(3, 78);
        for (int i = 0; i < listA.getLength(); i++) {
            System.out.println(listA.get(i));
        }
    }
}

class StaticLinkedList {
    private StaticLinkedNode[] linkedList = null; //静态链表的存放数组
    private int MAX_SIZE = 4; //该数组的储存大小
    private int curFree = 0; //当前空闲的位置
    private int size = 1;

    //返回该链表的长度
    public int getLength() {
        return size - 1;
    }

    public StaticLinkedList() {
        linkedList = new StaticLinkedNode[MAX_SIZE];
        for (int i = 0; i < linkedList.length; i++) {
            linkedList[i] = new StaticLinkedNode();
            linkedList[i].data = -1;
            linkedList[i].cur = i + 1;
        }
        curFree = 1; //当前空闲结点从1开始，0号位的结点设置为空，不存放数据
    }

    //添加
    public void add(int data) {
        if (size < linkedList.length) {
            linkedList[curFree].data = data;
            curFree = linkedList[curFree].cur;
            size++;
        } else {
            addLinkSpace();
            linkedList[curFree].data = data;
            curFree = linkedList[curFree].cur;
            size++;
        }
    }

    //获取指定索引的数据
    public int get(int index) {
        if (index > size - 1 && index < 0) {
            throw new RuntimeException("数组越界");
        } else {
            return linkedList[index + 1].data;
            //因为多了一个空的头节点，所以index+1
        }
    }

    //删除
    public void delete(int index) {
        index++; //因为空的头节点的存在
        if (index < 1 || index >= size) {
            throw new RuntimeException("删除的下标不合法");
        } else if (index == size - 1) {
            size--;
            linkedList = (StaticLinkedNode[]) getTrueIndex(linkedList, size);
        } else {
            int i = 0;
            while (index != linkedList[i].cur) {
                i++;
            }
            int j = 0;
            while (curFree != linkedList[j].cur) {
                j++;
            }
            linkedList[i].cur = linkedList[index].cur;
            linkedList[j].cur = index;
            linkedList[index].cur = curFree;
            curFree = index;
            size--;
            linkedList = (StaticLinkedNode[]) getTrueIndex(linkedList, size);
        }
    }

    //插入
    public void insert(int index, int data) {
        //这里加1的原因是因为链表的第0位为空节点，这里设置的头节点为空
        index = index + 1;
        if (size < linkedList.length) {
            if (index > size && index < 0)
                System.out.println("数组越界，超出数组长度");
            else if (index == size) {
                linkedList[curFree].data = data;
                curFree = linkedList[curFree].cur;
                size++;
            } else {
                //未按逻辑顺序排序而插入数据的写法，因为未排序，则当前索引的上个节点的索引不一定是当前索引减1
                int i = 0;
                while (index != linkedList[i].cur) {
                    i++;
                }
                int j = 0;
                while (curFree != linkedList[j].cur) {
                    j++;
                }
                linkedList[i].cur = curFree;
                linkedList[j].cur = linkedList[curFree].cur;
                linkedList[curFree].data = data;
                linkedList[curFree].cur = index;
                curFree = linkedList[j].cur;
                size++;
                //每次插入后将链表按逻辑顺序重新排序，是为了方便输出查看。
                linkedList = (StaticLinkedNode[]) getTrueIndex(linkedList, size);
            }
        } else {
            addLinkSpace();
            insert(index, data);
        }
    }

    //按照逻辑顺序来重新排列链表
    public Object getTrueIndex(StaticLinkedNode[] linkedList, int size) {
        StaticLinkedNode[] linkedNodes = new StaticLinkedNode[linkedList.length];
        int k = 0;
        for (int i = 0; i < linkedList.length; i++) {
            linkedNodes[i] = new StaticLinkedNode();
            linkedNodes[i].data = linkedList[k].data;
            k = linkedList[k].cur;
            linkedNodes[i].cur = i + 1;
        }
        //在删除之后，curFree不一定是最后一位
        curFree = size;
        return linkedNodes;
    }

    //扩展链表长度
    public void addLinkSpace() {
        MAX_SIZE += 8;
        StaticLinkedNode[] linkedNodes = linkedList;
        linkedList = new StaticLinkedNode[MAX_SIZE];
        System.arraycopy(linkedNodes, 0, linkedList, 0, linkedNodes.length);
        for (int i = linkedNodes.length; i < MAX_SIZE; i++) {
            linkedList[i] = new StaticLinkedNode();
            linkedList[i].data = -1;
            linkedList[i].cur = i + 1;
        }
        curFree = linkedNodes.length;
    }
}

class StaticLinkedNode {
    int data;
    int cur;
}
```

#### 一元多项式求和

```java
package linkedList;

public class PolynomialCountDemo {
    public static void main(String[] args) {
        String exp1 = "+1x^1,+3x^2,-4x^4";
        String exp2 = "+1x^2,+1x^3,+1x^4";
        System.out.println(countPolynomial(exp1, exp2));
    }

    public static String countPolynomial(String exp1, String exp2) {
        PolynomialList poly1 = new PolynomialList(exp1);
        PolynomialList poly2 = new PolynomialList(exp2);

        PolynomialNode curNode1 = poly1.head.next;
        PolynomialNode curNode2 = poly2.head.next;

        PolynomialNode temp = curNode1;

        while (temp != null && curNode2 != null) {
            if (temp.pow < curNode2.pow) {
                temp = temp.next;
            } else if (temp.pow > curNode2.pow) {
                PolynomialNode t = new PolynomialNode(curNode2.number, curNode2.pow);
                t.next = temp;
                temp = t;
                temp = temp.next;
                curNode2 = curNode2.next;
            } else {
                temp.number += curNode2.number;
                temp = temp.next;
                curNode2 = curNode2.next;
            }
        }

        if (curNode2 != null) {
            temp.next = curNode2.next;
        }

        String resultStr = "";
        while (curNode1 != null) {
            if (curNode1.number < 0) {
                resultStr += curNode1.number + "x^" + curNode1.pow + ",";
            } else {
                resultStr += "+" + curNode1.number + "x^" + curNode1.pow + ",";
            }
            curNode1 = curNode1.next;
        }
        return resultStr.substring(0,resultStr.length() - 1);
    }
}

class PolynomialList {
    public PolynomialNode head;

    public PolynomialList() {
        this.head = new PolynomialNode();
    }

    public PolynomialList(String express) {
        head = new PolynomialNode();
        PolynomialNode curNode = head;
        String[] polyInfo = express.split(",");
        for (int i = 0; i < polyInfo.length; i++) {
            String temp = polyInfo[i];
            int number = Integer.parseInt(temp.substring(0, temp.indexOf('x')));
            int pow = Integer.parseInt(temp.substring(temp.indexOf('^') + 1));
            curNode.next = new PolynomialNode(number, pow);
            curNode = curNode.next;
        }
    }
}

class PolynomialNode {
    int number; //系数
    int pow; //指数
    PolynomialNode next = null;

    public PolynomialNode() {
    }

    public PolynomialNode(int number, int pow) {
        this.number = number;
        this.pow = pow;
    }
}
```

### 栈

- 先进后出，后进先出。
- 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的
一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)

![](c:/notebook/pictures/Snipaste_2022-12-18_20-10-38.png =900x)
![](c:/notebook/pictures/Snipaste_2022-12-18_20-11-34.png =500x)

```java
package stack;

public class ArrayStackDemo {
    public static void main(String[] args) {
        ArrayStack stack = new ArrayStack(10);
        stack.push(2);
        stack.push(3);
        stack.push(5);
        stack.push(1);
        stack.show();
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}

class ArrayStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组 模拟栈，存放数据
    private int top = -1; //栈顶 初始化-1

    public ArrayStack(int maXSize) {
        this.maxSize = maXSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //压栈push
    public void push(int value) {
        //判断是否栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }

        stack[++top] = value;
    }

    //弹栈pop
    public int pop() {
        //判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }

        return stack[top--];
    }

    //遍历栈，从top栈顶开始
    public void show() {
        //判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }

        for (int i = top; i >= 0; i--) {
            System.out.println("stack[" + i + "] = " + stack[i]);
        }
    }
}
```

#### 综合计算器 中缀表达式

![](c:/notebook/pictures/Snipaste_2022-12-18_20-46-13.png =800x)

```java
package stack;

public class CalculatorTest {
    public static void main(String[] args) {
        String expression = "30+6*3-2";
        //创建数字栈和符号栈
        NumberStack numberStack = new NumberStack(10);
        OperatorStack operatorStack = new OperatorStack(10);
        //定义需要的相关变量
        int index = 0; // 用于扫描
        int num1 = 0;
        int num2 = 0;
        int operator = 0;
        int result = 0;
        char temp = ' '; //将每次扫描的char保存到temp
        String keepNumber = ""; //用于拼接多位数

        //while循环扫描expression
        while (true) {
            //依次得到expression中的每个字符
            temp = expression.substring(index, index + 1).charAt(0);
            //判断temp是数字还是符号,进行相应的处理
            if (operatorStack.isOperator(temp)) { //如果是符号
                //判断当前符号栈是否为空
                if (operatorStack.isEmpty()) { //空：直接入栈
                    operatorStack.push(temp);
                } else { //非空：如果当前符号栈中有符号，比较优先级
                    //如果当前的运算符的优先级<=当前栈中的运算符，则pop两个数字和一个运算符进行计算
                    if (operatorStack.priority(temp) <= operatorStack.priority(operatorStack.peek())) {
                        num1 = numberStack.pop();
                        num2 = numberStack.pop();
                        result = operatorStack.calculate(num1, num2, operatorStack.pop());
                        //将计算的结果入栈
                        numberStack.push(result);
                        //将当前的运算符入栈
                        operatorStack.push(temp);
                    } else {//如果当前的运算符的优先级>当前栈中的运算符,则将当前的压入栈
                        operatorStack.push(temp);
                    }
                }
            } else { //如果是数，直接入数栈
                keepNumber += temp;
                //判断是否为表达式最后一位，最后一位则直接入栈
                if (index == expression.length() - 1) {
                    numberStack.push(temp - 48); //注意ASCII码的对应
                } else {
                    //判断下一个字符是否为数字，如果是数字则继续扫描，如果是运算符则入栈。
                    if (operatorStack.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {
                        //如果后一位是运算符，则入栈
                        numberStack.push(Integer.parseInt(keepNumber));
                        //清空keepNumer
                        keepNumber ="";
                    }
                }
            }
            //让index+1，并判断是否扫描到expression最后
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //当表达式扫描完毕，顺序的从数栈和符号栈中pop出相应的数和符号
        while (true) {
            //如果符号栈为空，则为计算到最后结果，此时数字栈中只有一个数（结果）
            if (operatorStack.isEmpty()) {
                break;
            }
            num1 = numberStack.pop();
            num2 = numberStack.pop();
            //
            result = operatorStack.calculate(num1, num2, operatorStack.pop());
            numberStack.push(result);
        }
        System.out.println(numberStack.pop());
    }
}

class NumberStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组 模拟栈，存放数据
    private int top = -1; //栈顶 初始化-1

    public NumberStack(int maXSize) {
        this.maxSize = maXSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //压栈push
    public void push(int value) {
        //判断是否栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }

        stack[++top] = value;
    }

    //弹栈pop
    public int pop() {
        //判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }

        return stack[top--];
    }

    //遍历栈，从top栈顶开始
    public void show() {
        //判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }

        for (int i = top; i >= 0; i--) {
            System.out.println("stack[" + i + "] = " + stack[i]);
        }
    }
}

class OperatorStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组 模拟栈，存放数据
    private int top = -1; //栈顶 初始化-1

    public OperatorStack(int maXSize) {
        this.maxSize = maXSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //压栈push
    public void push(int value) {
        //判断是否栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }

        stack[++top] = value;
    }

    //弹栈pop
    public int pop() {
        //判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }

        return stack[top--];
    }

    //遍历栈，从top栈顶开始
    public void show() {
        //判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }

        for (int i = top; i >= 0; i--) {
            System.out.println("stack[" + i + "] = " + stack[i]);
        }
    }

    //返回运算符的优先级 使用数字表示，数字越大，优先级越高
    public int priority(int operator) {
        //假定只有+-*/
        if (operator == '*' || operator == '/') {
            return 1;
        } else if (operator == '+' || operator == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    //判断是否为运算符
    public boolean isOperator(char operator) {
        return operator == '+' || operator == '-' || operator == '*' || operator == '/';
    }

    //计算方法
    public int calculate(int num1, int num2, int operator) {
        int result = 0; //存放计算的结果
        switch (operator) {
            case '+':
                result = num1 + num2;
                break;
            case '-': //注意这里的顺序,因为是后进先出
                result = num2 - num1;
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/': //注意这里的顺序,因为是后进先出
                result = num2 / num1;
                break;
            default:
                break;
        }
        return result;
    }

    //返回当前栈顶的值，但并非pop
    public int peek() {
        return stack[top];
    }
}
```

#### 中缀、前缀、后缀表达式

##### 中缀表达式

- 一般转后缀

##### 前缀表达式 波兰表达式

- 前缀表达式的运算符位于操作数之前

**前缀表达式的计算机求值**

- 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

![](c:notebook/pictures/Snipaste_2022-12-19_21-30-18.png =700x)

##### 后缀表达式 逆波兰表达式

- 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

![](c:/notebook/pictures/Snipaste_2022-12-19_21-31-53.png =400x)

#### 逆波兰计算器 后缀表达式

![](C:/notebook/pictures/Snipaste_2022-12-19_21-37-16.png =700x)

```java
package stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //4+(5+6)*2 --> 5 6 + 2 * 4 +
        String suffixExpression = "5 6 + 2 * 4 + ";
        //1.先放入ArrayList中
        //2.将ArrayList传递给方法，遍历ArrayList配合栈完成计算
        List<String> rpnList = getListString(suffixExpression);
        System.out.println(calculate(rpnList));
    }

    //将一个逆波兰表达式，依次将数字和运算符放入ArrayList
    public static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String str : split) {
            list.add(str);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    public static int calculate(List<String> list) {
        //创建栈,一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String str : list) {
            //使用正则表达式，取出数
            if (str.matches("\\d+")) { //可以匹配多位数
                //入栈
                stack.push(str);
            } else { //如果是运算符
                //pop两个数，并运算，再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int result = 0;
                if (str.equals("+")) {
                    result = num1 + num2;
                } else if (str.equals("-")) {
                    result = num1 - num2;
                } else if (str.equals("*")) {
                    result = num1 * num2;
                } else if (str.equals("/")) {
                    result = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把计算结果入栈
                stack.push("" + result);
            }
        }
        //最后pop运算结果
        return Integer.parseInt(stack.pop());
    }
}
```

#### 中缀转后缀

![](c:/notebook/pictures/Snipaste_2022-12-19_22-11-36.png =800x)
![](c:/notebook/pictures/Snipaste_2022-12-19_22-28-57.png =600x)

```java
//将中缀表达式转为对应的List
public static List<String> toInfixExpression(String infixExpression) {
    //定义List存放中缀表达式对应的内容
    List<String> list = new ArrayList<>();
    int index = 0; //指针，用于遍历中缀表达式
    String keepNumber; //多位数的拼接
    char temp; //遍历到的每个字符
    do {
        //如果非数字，则加入list //ASCII码 0~9对应68~57
        if ((temp = infixExpression.charAt(index)) < 48 || (temp = infixExpression.charAt(index)) > 57) {
            list.add("" + temp);
            index++;
        } else { //如果是数字，则拼接
            keepNumber = "";
            while (index < infixExpression.length() && (temp = infixExpression.charAt(index)) >= 48 && (temp = infixExpression.charAt(index)) <= 57) {
                keepNumber += temp;
                index++;
            }
            list.add(keepNumber);
        }
    } while (index < infixExpression.length());
    return list;
}

//将一个中缀表达式对应的List转换成后缀表达式, 放入到List中
public static List<String> parseSuffixExpressionList(List<String> infixList) {
    //定义两个栈 符号栈和中间结果的存储栈
    Stack<String> operatorStack = new Stack<>();
    //直接使用List<String> 替换中间结果的存储栈
//        Stack<String> numberStack = new Stack<>();
    List<String> resultList = new ArrayList<>();

    //遍历infixList
    for (String str : infixList) {
        //如果是数字，加入resultList
        if (str.matches("\\d+")) {
            resultList.add(str);
        } else if (str.equals("(")) { //左括号"("直接压入operatorStack
            operatorStack.push(str);
        } else if (str.equals(")")) {
            //如果是右括号")"，则依次pop出operatorStack中的运算符，并压入resultList,直到遇到左括号"("为止
            while (!operatorStack.peek().equals("(")) {
                resultList.add(operatorStack.pop());
            }
            operatorStack.pop(); //将 "(" 弹出，消除小括号
        } else {
            //当str的优先级<=operator栈顶的运算符的优先级，弹出operator中的运算符并加入到resultList中，再次转到与operatorStack新的运算符比较
            while (operatorStack.size() != 0 && Operation.getValue(operatorStack.peek()) >= Operation.getValue(str)) {
                resultList.add(operatorStack.pop());
            }
            //将str压入栈
            operatorStack.push(str);
        }
    }

    //将operatorStack中剩余的运算符依次弹出，并加入resultList
    while (operatorStack.size() != 0) {
        resultList.add(operatorStack.pop());
    }
    return resultList;
}


class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //返回运算符的优先级
    public static int getValue(String operation) {
        int result;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
//                throw new RuntimeException("不存在该运算符");
                result = 0;
        }

        return result;
    }
}
```

#### 两栈共享空间

**具体实现**

- 利用顺序栈单向延申的特性，使用一个数组来存放两个栈。
- 栈一的栈顶top1为该数组的0下标开始，每次top1++存放新的元素；栈二的栈顶top2为该数组的length-1下标开始，每次top--存放新的元素 。
- 满栈：top1 == top2 - 1
- 设置变量type来区分操作两个栈

```java
package stack;

public class BothStackDemo {
    public static void main(String[] args) {
        BothStack bothStack = new BothStack(10);
        bothStack.push('+', 1);
        bothStack.push('-', 1);
        bothStack.push('5', 2);
        bothStack.push('*', 1);
        bothStack.push('4', 2);
        bothStack.push('1', 2);

        System.out.println(bothStack.pop(1) + "--");
        System.out.println(bothStack.pop(1) + "--");
        System.out.println(bothStack.pop(2) + "--");
    }
}

class BothStack {
    char[] bothStack = new char[20];
    int top1 = 0; //stack1的栈顶
    int top2 = bothStack.length - 1; //stack2的栈顶

    public BothStack(int length) {
        bothStack = new char[length];
        this.top1 = 0; //stack1的栈顶
        this.top2 = bothStack.length - 1; //stack2的栈顶
    }

    public void push(char value, int type) {
        //判断是否栈满
        if (top1 == top2 - 1) {
            throw new RuntimeException("栈满");
        }

        //按不同的栈操作
        if (type == 1) {
            bothStack[top1++] = value;
        } else if (type == 2) {
            bothStack[top2--] = value;
        } else {
            throw new RuntimeException("未选择正确的栈");
        }
    }

    public char pop(int type) {
        //按不同的栈操作
        if (type == 1) {
            if (top1 == 0) {
                throw new RuntimeException("stack1栈空");
            }
            return bothStack[--top1];
        } else if (type == 2) {
            if (top1 == bothStack.length - 1) {
                throw new RuntimeException("stack2栈空");
            }
            return bothStack[++top2];
        } else {
            throw new RuntimeException("未选择正确的栈");
        }
    }
}
```

## 树

- 非线性层次关系

**特点**

1. 有且只有一个根节点（一个节点也可以是树）
2. 每个节点只有一个父节点
3. 一个节点可以有多个子节点

**二叉树**

1. 一个节点最多有两个子节点
2. 二叉树是有序树，有左右之分

- 节点的度：该节点拥有的子节点数
- 树的度：树中最大的节点的度

![](c:/notebook/pictures/Snipaste_2022-12-31_21-47-01.png =1000x)

### 二叉树

- 从任意节点开始，节点左侧节点值总比节点右侧值要小。

![](C:/notebook/pictures/Snipaste_2022-12-31_22-00-13.png =600x)

```java
package tree;

import java.util.Scanner;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int menusel;

        //树的初始化
        Init tree = new Init();
        BinarySortTreeNode root = tree.InitTree();
        do {
            System.out.println("---------菜单-------");
            System.out.println("0.退出\t1.添加结点");
            menusel = scanner.nextInt();
            switch (menusel) {
                case 1:
                    tree.AddTreeNode(root);
                    break;
                case 0:
                    break;
                default:
                    ;
            }
        } while (menusel != 0);

        //遍历
        do {
            System.out.println("选择遍历的方式：1.DLR、2.LDR、3.LRD、4.Level");
            menusel = scanner.nextInt();
            switch (menusel) {
                case 1:
                    System.out.println("先序遍历DLR：");
                    tree.DLRTree(root);
                    break;
                case 2:
                    System.out.println("中序遍历LDR：");
                    tree.LDRTree(root);
                    break;
                case 3:
                    System.out.println("后序遍历：");
                    tree.LRDTree(root);
                    break;
                case 4:
                    System.out.println("按层遍历：");
                    tree.levelTree(root);
                    break;
                default:
                    ;
            }
        } while (menusel != 0);

        System.out.printf("该二叉树的深度：%d\n", tree.treeDepth(root));

        //清空树，释放资源
        tree.clearTree(root);
        root = null;
    }
}

/*二叉树节点类*/
class BinarySortTreeNode {
    public int data;
    public BinarySortTreeNode left;
    public BinarySortTreeNode right;
}

/*树*/
class Init {
    static final int MAXLEN = 20;//最大结点数
    static Scanner scanner = new Scanner(System.in);

    //构造初始结点root
    public BinarySortTreeNode InitTree() {
        BinarySortTreeNode node;
        if ((node = new BinarySortTreeNode()) != null) {
            System.out.println("输入根节点的值：");
            node.data = scanner.nextInt();
            node.left = null;
            node.right = null;
            if (node != null) {
                return node;
            } else {
                return null;
            }
        }
        return null;
    }

    //添加 为结点添加子树
    public void AddTreeNode(BinarySortTreeNode node) {
        BinarySortTreeNode pnode, parent; //当前结点/父节点
        int data; //值
        int menusel; //选择左/右子树

        if ((pnode = new BinarySortTreeNode()) != null) {
            System.out.println("输入结点数据：");
            pnode.data = scanner.nextInt();
            pnode.left = null;
            pnode.right = null;

            //判断父节点是否存在
            System.out.println("输入父节点数据：");
            data = scanner.nextInt();
            parent = treeFindNode(node, data); //父结点
            if (parent == null) { //如果父节点不存在
                System.out.println("未找到父节点，请重新输入");
                pnode = null; //重置
                return;
            }

            //选择添加的位置
            System.out.println("添加该节点至：1.左子树、2.右子树");
            do {
                menusel = scanner.nextInt();
                if (menusel == 1 || menusel == 2) {
                    if (parent == null) {
                        System.out.println("不存在父节点");
                    } else {
                        switch (menusel) {
                            case 1:
                                if (parent.left != null) { //判断子树是否为空
                                    System.out.println("左子树结点不为空");
                                } else {
                                    parent.left = pnode;
                                }
                                break;
                            case 2:
                                if (parent.right != null) {
                                    System.out.println("右子树结点不为空");
                                } else {
                                    parent.right = pnode;
                                }
                                break;
                            default:
                                System.out.println("该选项无效");
                                break;
                        }
                    }
                }
            } while (menusel != 1 && menusel != 2);
        }
    }

    //查找结点 如果结点node的值和data匹配则返回该结点
    BinarySortTreeNode treeFindNode(BinarySortTreeNode node, int data) {
        BinarySortTreeNode ptr;
        if (node == null) {
            return null;
        } else {
            if (node.data == data) {
                return node;
            } else {
                if ((ptr = treeFindNode(node.left, data)) != null) {
                    return ptr;
                } else {
                    return null;
                }
            }
        }
    }

    //返回左子树
    BinarySortTreeNode treeLeftNode(BinarySortTreeNode node) {
        if (node != null) {
            return node.left;
        } else {
            return null;
        }
    }

    //返回右子树
    BinarySortTreeNode treeRightNode(BinarySortTreeNode node) {
        if (node != null) {
            return node.right;
        } else {
            return null;
        }
    }

    //该树是否为空
    int treeIsEmpty(BinarySortTreeNode node) {
        if (node != null) {
            return 0;
        } else {
            return 1;
        }
    }

    //树的深度
    int treeDepth(BinarySortTreeNode node) {
        int depLeft, depRight;
        if (node == null) {
            return 0;
        } else {
            depLeft = treeDepth(node.left);
            depRight = treeDepth(node.right);
            if (depLeft > depRight) {
                return depLeft + 1;
            } else {
                return depRight + 1;
            }
        }
    }

    //清空树
    void clearTree(BinarySortTreeNode node) {
        if (node != null) {
            clearTree(node.left);
            clearTree(node.right);
            node = null;
        }
    }

    //返回结点的数据
    void treeNodeData(BinarySortTreeNode node) {
        System.out.print("[" + node.data + "]");
    }

    //按层遍历 上至下，左至右的顺序
    public void levelTree(BinarySortTreeNode node) {
        //需要使用队列辅助
        BinarySortTreeNode curNode;
        BinarySortTreeNode[] nodeQuery = new BinarySortTreeNode[MAXLEN];
        int head = 0, tail = 0;

        //先判断树是否为空
        if (node != null) {
            tail = (tail + 1) % MAXLEN;
            nodeQuery[tail] = node;
        }
        while (head != tail) {
            head = (head + 1) % MAXLEN;
            curNode = nodeQuery[head];

            treeNodeData(curNode);//输出

            //如果当前结点存在子树
            if (curNode.left != null) {
                tail = (tail + 1) % MAXLEN;
                nodeQuery[tail] = curNode.left;
            }
            if (curNode.right != null) {
                tail = (tail + 1) % MAXLEN;
                nodeQuery[tail] = curNode.right;
            }
        }
    }

    //先序遍历 DLR
    void DLRTree(BinarySortTreeNode node) {
        if (node != null) {
            treeNodeData(node);//输出
            DLRTree(node.left);
            DLRTree(node.right);
        }
    }

    //中序遍历 LDR
    void LDRTree(BinarySortTreeNode node) {
        if (node != null) {
            LDRTree(node.left);
            treeNodeData(node);//输出
            LDRTree(node.right);
        }
    }

    //后序遍历 LRD
    void LRDTree(BinarySortTreeNode node) {
        if (node != null) {
            LRDTree(node.left);
            LRDTree(node.right);
            treeNodeData(node);//输出
        }
    }
}
```

#### 堆（完全二叉树）

**如果使用数组实现**

- 按照从左往右的顺序
- rootIndex = 0
- leftNodeIndex = curNodeIndex * 2 + 1
- rightNodeIndex = curNodeIndex * 2 + 2
- 堆的非叶子结点数 = 堆的总长度 / 2
- 堆的非叶子结点数 = 堆的总长度 / 2 + 1

```java

```

### 森林

- 森林是m棵互不相交的树的集合

#### 树转为二叉树

1. 为树中的所有相邻的兄弟结点之间加线
2. 保留根结点和第一个子结点的连线，去除根结点与其他子结点的连线
3. 层次调整
   - 树的前序遍历等于二叉树的前序遍历
   - 树的后序遍历等于二叉树的中序遍历

#### 森林转二叉树

1. 将森林的每棵树转为二叉树
2. 将所有的树的根结点视为兄弟结点，并连线
3. 层次调整
   - 森林的前序遍历等于二叉树的前序遍历
   - 森林的后序遍历等于二叉树的中序遍历
   
#### 二叉树转树/森林

1. 若该结点是其父节点的左结点，则将其右节点、右节点的子右节点……与其父节点相连
2. 删除二叉树中所有的父节点与右节点的连线
3. 层次调整

### 最优二叉树（哈夫曼树）

- 叶子结点的权值
- 二叉树的带权路径长度：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和
- 哈夫曼树：带权路径长度最小的二叉树
   - 使权值越大的叶子结点越靠近根结点，且不存在度为1的结点。
   
![](c:/notebook/pictures/Snipaste_2023-02-13_16-23-42.png =800x)
![](c:/notebook/pictures/Snipaste_2023-02-13_16-24-56.png =800x)

```java
package tree;

import java.util.*;

public class HuffmanTreeDemo {
    public static void main(String[] args) {
        List<HuffmanTreeNode> list = new ArrayList<>();
        list.add(new HuffmanTreeNode(2));
        list.add(new HuffmanTreeNode(3));
        list.add(new HuffmanTreeNode(6));
        list.add(new HuffmanTreeNode(8));
        HuffmanTree tree = new HuffmanTree();
        tree.nodes = list;
        tree.createTree();
        System.out.println(tree.getWeight());
    }
}

class HuffmanTree {
    private HuffmanTreeNode root;
    List<HuffmanTreeNode> nodes;

    public HuffmanTree() {
        this.nodes = null;
    }

    public HuffmanTree(List<HuffmanTreeNode> nodes) {
        this.nodes = nodes;
    }

    public void createTree() {
        Queue<HuffmanTreeNode> queue = new PriorityQueue<>(new Comparator<HuffmanTreeNode>() {
            @Override
            public int compare(HuffmanTreeNode o1, HuffmanTreeNode o2) {
                return o1.value - o2.value;
            }
        });
        queue.addAll(nodes);

        while (!queue.isEmpty()) {
            HuffmanTreeNode n1 = queue.poll();
            HuffmanTreeNode n2 = queue.poll();
            HuffmanTreeNode parent = new HuffmanTreeNode(n1.value + n2.value, n1, n2);
            if (queue.isEmpty()) {
                root = parent;
                return;
            }
            queue.add(parent);
        }
    }

    public int getWeight() {
        Queue<HuffmanTreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        int weight = 0;
        while (!queue.isEmpty()) {
            HuffmanTreeNode curNode = queue.poll();
            if (curNode.left != null) {
                curNode.left.deep = curNode.deep + 1;
                curNode.right.deep = curNode.deep + 1;
                queue.add(curNode.left);
                queue.add(curNode.right);
            } else {
                weight += curNode.deep * curNode.value;
            }
        }
        return weight;
    }
}

class HuffmanTreeNode {
    int value;
    HuffmanTreeNode left;
    HuffmanTreeNode right;
    int deep;

    public HuffmanTreeNode(int value) {
        this.value = value;
        this.deep = 0;
    }

    public HuffmanTreeNode(int value, HuffmanTreeNode left, HuffmanTreeNode right) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
```

#### 哈夫曼编码

![](c:/notebook/pictures/Snipaste_2023-02-14_00-28-09.png =400x)

```java

```

### 字典树

- 字典树，是一种**空间换时间**的数据结构，又称Trie树、前缀树，是一种树形结构(字典树是一种数据结构)，典型用于统计、排序、和保存大量字符串。所以经常被搜索引擎系统用于文本词频统计。
- 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
- 首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。

**重要性质：**

1. 根节点不包含字符，除了根节点每个节点都只包含一个字符。root节点不含字符这样做的目的是为了能够包括所有字符串。
2. 从根节点到某一个节点，路过字符串起来就是该节点对应的字符串。
3. 每个节点的子节点字符不同，也就是找到对应单词、字符是唯一的。

![](c:/notebook/pictures/Snipaste_2023-02-14_20-24-27.png =500x)


```java
package tree;

import java.util.HashMap;
import java.util.Map;

public class TrieTreeDemo {
    public static void main(String[] args) {
        Trie trie = new Trie();
        trie.insert("test");
        trie.insert("try");
        trie.insert("find");
        System.out.println(trie.starWith("i"));
        System.out.println(trie.search("try"));
    }
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
        root.worldEnd = false;
    }

    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            Character character = word.charAt(i);
            //如果当前结点没有包含相关的后缀，则设置并获取该字符
            if (!node.childdren.containsKey(character)) {
                node.childdren.put(character, new TrieNode());
            }
            node = node.childdren.get(character);
        }
        node.worldEnd = true;
    }

    //全词匹配
    public boolean search(String word) {
        TrieNode node = root;
        boolean found = true;
        for (int i = 0; i < word.length(); i++) {
            Character character = word.charAt(i);
            if (!node.childdren.containsKey(character)) {
                return false;
            }
            node = node.childdren.get(character);
        }
        return found && node.worldEnd;
    }

    //前缀匹配
    public boolean starWith(String prefix) {
        TrieNode node = root;
        boolean found = true;
        for (int i = 0; i < prefix.length(); i++) {
            Character character = prefix.charAt(i);
            if (!node.childdren.containsKey(character)) {
                return false;
            }
            node = node.childdren.get(character);
        }
        return found;
    }
}

class TrieNode {
    Map<Character, TrieNode> childdren;
    boolean worldEnd;

    public TrieNode() {
        childdren = new HashMap<>();
        worldEnd = false;
    }
}
```

## 图

```java
package figure;

import java.util.Scanner;

public class GraphDemo {
    public static void main(String[] args) {
        GraphMatrix graphMatrix = new GraphMatrix();
        System.out.print("输入生成图的类型：");
        graphMatrix.graphType = scan.nextInt();
        System.out.print("输入图的顶点数量：");
        graphMatrix.vertexNum = scan.nextInt();
        System.out.print("输入图的边数量：");
        graphMatrix.edgeNum = scan.nextInt();

        clearGraph(graphMatrix);

        createGraph(graphMatrix);

        System.out.println("该图的邻接矩阵：");
        printGraph(graphMatrix);
        deepTraGraph(graphMatrix);
    }

    public static Scanner scan = new Scanner(System.in);

    /**
     * 初始化图
     *
     * @param graphMatrix
     */
    public static void createGraph(GraphMatrix graphMatrix) {
        int weight; //权
        char startVertex, endVertex; //边的起点和终点

        //输入顶点的数据
        System.out.println("输入图中各顶点数据：");
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            System.out.printf("第%d个顶点：", i + 1);
            graphMatrix.vertex[i] = scan.next().toCharArray()[0];
        }
        System.out.println("输入构成各边的顶点和权值：");
        for (int i = 0; i < graphMatrix.edgeNum; i++) {
            System.out.printf("第%d条边：", i + 1);
            System.out.println("起点");
            startVertex = scan.next().charAt(0);
            System.out.println("终点");
            endVertex = scan.next().charAt(0);
            System.out.println("权值");
            weight = scan.nextInt();
            //查找相应的起点和终点
            int j, k;
            for (j = 0; startVertex != graphMatrix.vertex[j]; j++) ;
            for (k = 0; endVertex != graphMatrix.vertex[k]; k++) ;
            graphMatrix.edgeWeight[j][k] = weight; //有向图只存放当前方向的权值
            if (graphMatrix.graphType == 0) { //无向图补充另一个方向的权值
                graphMatrix.edgeWeight[k][j] = weight;
            }
        }
    }

    /**
     * 清空图
     *
     * @param graphMatrix
     */
    public static void clearGraph(GraphMatrix graphMatrix) {
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            for (int j = 0; j < graphMatrix.vertexNum; j++) {
                graphMatrix.edgeWeight[i][j] = graphMatrix.MAXVALUE;
            }
        }
    }

    /**
     * 输出邻接矩阵
     *
     * @param graphMatrix
     */
    public static void printGraph(GraphMatrix graphMatrix) {
        for (int i = 0; i < graphMatrix.vertexNum; i++) {//顶点信息
            System.out.printf("\t%c", graphMatrix.vertex[i]);
        }
        System.out.println();
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            System.out.printf("%c", graphMatrix.vertex[i]);
            for (int j = 0; j < graphMatrix.vertexNum; j++) {
                if (graphMatrix.edgeWeight[i][j] == GraphMatrix.MAXVALUE) {
                    System.out.print("\tZ");//表示无权值（无穷大）
                } else {
                    System.out.printf("\t%d", graphMatrix.edgeWeight[i][j]);
                }
            }
            System.out.println();
        }
    }

    /**
     * 深度遍历
     *
     * @param graphMatrix
     * @param n           从第n个结点开始
     */
    public static void deepTraOne(GraphMatrix graphMatrix, int n) {
        //清除之前遍历的标识
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            graphMatrix.isTrav[i] = 0;
        }

        graphMatrix.isTrav[n] = 1; //标记该顶点已处理
        System.out.printf("->%c", graphMatrix.vertex[n]);

        //处理结点
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            if (graphMatrix.edgeWeight[n][i] != GraphMatrix.MAXVALUE && graphMatrix.isTrav[n] == 0) {
                deepTraOne(graphMatrix, i);
            }
        }
    }

    /**
     * 深度优先遍历
     *
     * @param graphMatrix
     */
    public static void deepTraGraph(GraphMatrix graphMatrix) {
        //清除之前遍历的标识
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            graphMatrix.isTrav[i] = 0;
        }

        System.out.print("深度优先遍历结点：");
        for (int i = 0; i < graphMatrix.vertexNum; i++) {
            if (graphMatrix.isTrav[i] == 0) {
                deepTraOne(graphMatrix, i); //调用深度遍历
            }
        }
        System.out.println();
    }
}

class GraphMatrix {
    static final int MAXNUM = 20; //最大顶点数
    static final int MAXVALUE = 65535; //权值总和最大值
    char[] vertex = new char[MAXNUM];//保存顶点数据
    int graphType; //图的类型：0无向图，1有向图
    int vertexNum; //顶点数量
    int edgeNum; //边数量
    int[][] edgeWeight = new int[MAXNUM][MAXNUM];//保存顶点的边信息
    int[] isTrav = new int[MAXNUM];//遍历标识
}
```

### 最小生成树

#### Kruskal算法

`Kruskal`算法进行调度的单位是边,它的信仰为:**所有边能小则小**，算法的实现方面和**并查集(不相交集合)很像**，要用到并查集判断两点是否在同一集合。

**算法的具体步骤为：**

1. 将边(以及2顶点)的对象依次加入集合(优先队列)`q1`中。**初始所有点相互独立**。
2. 取出当前`q1`最小边，判断边的两点是否联通。
3. **如果联通**，跳过，**如果不连通**，则使用`union`（并查集合并）将两个顶点合并。这条边被使用(可以储存或者计算数值)。
4. 重复2，3操作直到集合（优先队列）`q1`为空。此时被选择的边构成最小生成树。

```java

```

#### Prim算法

prim算法的核心信仰是：**从已知扩散寻找最小**。它的实现方式和`Dijkstra`算法相似但稍微有所区别，Dijkstra是求单源最短路径。而每计算一个点需要对这个点从新更新距离。而prim甚至不用更新距离。**直接找已知点的邻边最小加入**即可！

**具体算法具体步骤，大致为：**

1. 寻找图中**任意点**，以它为起点，它的**所有边V加入集合(优先队列)**`q1`,设置一个`boolean数组bool[]`标记该位置已经确定。
2. 从集合q1找到**距离最小**的那个边`v1`并**判断边另一点p是否被标记(访问)**，如果`p`被标记说明已经确定那么跳过，如果未被标(访问)记那么标记该点`p`,并且**与p相连的未知点(未被标记)构成的边**加入集合`q1`，**边v1(可以进行计算距离之类，该边构成最小生成树)** .
3. 重复1，2直到q1为空，构成最小生成树 ！

```java

```

## 散列表

# 算法

## 穷举算法

- 在明确知道问题的答案范围时，从所有的可能中搜索正确的。

### 鸡兔同笼

- 今有鸡兔同笼，上有三十五头，下有九十四足，问鸡兔几何？

```java
package exhaustive;

public class JiTu {
    public static void main(String[] args) {
        count(35,94);
    }

    public static void count(int head, int foot) {
        for (int i = 0; i < head; i++) { //i 为鸡头数量
            if ((i * 2 + (head - i) * 4) == foot) {
                System.out.println("鸡：" + i + "兔：" + (head - i));
            }
        }
    }
}
```

## 递归

**重点：对子问题的处理**

- 递归是自己调用自己
- 递归通常不在意具体操作，只关心**初始条件**、**结束条件**和**上下层的变化关系**。
- 递归函数需要有**临界停止点(结束条件)**，即递归不能无限制的执行下去。通常这个点为必须经过的一个数。
- 递归可以被栈替代。有些递归可以优化。比如遇到重复性的可以借助空间内存记录而减少递归的次数

![](c:/notebook/pictures/Snipaste_2023-02-21_20-48-55.png =800x)

### 阶乘

```java
public static int factorial(int num) {
    if (num == 0) {
        return 1;
    }else{
        return num * factorial(--num);
    }
}
```

### 斐波那契数列

- 求斐波那契的公式为：`F[n]=F[n-1]+F[n-2](n>=3,F[1]=1,F[2]=1)`

```java
public static int fibonacci(int num) {
    if (num <= 2) {
        return -1;
    } else {
        return fibonacci(num - 1) + factorial(num - 2);
    }
}
```

### 兔子产仔

- 如果一对两个月大的兔子以后每一个月都可以生一对小兔子，而一对新生的兔子出生两个月后才可以生小兔子。也就是说，1月份出生，3月份才可产仔。那么假定一年内没有发生兔子死亡事件，那么1年后共有多少对兔子呢？

1. 第一个月：1 1对小兔子
2. 第二个月：1 1对中兔子
3. 第三个月：2 1对大兔子 1对小兔子 
4. 第四个月：3 1对大兔子 1对中兔子 1对小兔子
5. 第五个月：5 2对大兔子 1对中兔子 2对小兔子
6. 第六个月：8 3对大兔子 2对中兔子 3对小兔子
7. 第六个月：13 5对大兔子 3对中兔子 5对小兔子
8. 。。。

- 函数关系为：F(n) = F(n-1) + F(n-2)

```java
package recursion;

public class RabbitBirth {
    public static void main(String[] args) {
        System.out.println(birth(12));
    }
    public static int birth(int n) { //n 月份
        if (n == 1 || n == 2) {
            return 1;
        }
        return birth(n - 1) + birth(n - 2);
    }
}
```

### 汉诺塔

[汉诺塔.](https://www.cnblogs.com/dmego/p/5965835.html#:~:text=汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。.%20大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。.%20大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。.%20并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。.%20二．抽象为数学问题：.%20如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数.%20解：（1）n%20%3D%3D,sum%20%3D%201%20次.%20%282%29%20n%20%3D%3D%202.)

![](c:/notebook/pictures/20190816222824744.gif =500x)

- 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
   - (1) 每次只能移动一个盘子;
   - (2) 盘子只能从柱子顶端滑出移到下一根柱子;
   - (3) 盘子只能叠在比它大的盘子上。
- 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子

**解**

- n = 1 时，直接把盘子从 A 移到 C；
- n > 1 时，
    - 先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
    - 再将最大的盘子从 A 移到 C；
    - 再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlate(A.size(), A, B, C);
    }

    private void movePlate(int size, List<Integer> a, List<Integer> b, List<Integer> c){
        if(size == 1){ //到达最后一个
            int val = a.remove(a.size() - 1);
            c.add(val);
            return;
        }

        movePlate(size - 1, a, c, b);  //子问题：
        c.add(a.remove(a.size() - 1)); //
        movePlate(size - 1 , b, a, c); //子问题：
    }
}
```

- 错解：违背小盘子只能在大盘子上

```java
public class FactorialTest {
    public static void main(String args[]) {
        List<Integer> A = new ArrayList<Integer>();
        List<Integer> B = new ArrayList<Integer>();
        List<Integer> C = new ArrayList<Integer>();
        for (int i = 0; i < 10; i++) {
            A.add(i);
        }
        System.out.println(A);
        hannotTower(A, B, C, 1);
        System.out.println(B);
        System.out.println(C.toString());
    }

    public static void hannotTower(List<Integer> A, List<Integer> B, List<Integer> C, int key) {
        //当A的长度为1时，即停止
        if (A.size() == 0) {
            return;
        }
        //初始化C
        if (key-- > 0) {
            C.add(A.remove(A.size() - 1));
        }
        //当C的底盘大于A的顶时，直接将A的顶放入C，
        //否则将C的全部放入B，再将A的放入C，然后将B的再放入C
        move(A, B, C);
        hannotTower(A, B, C, key);
    }

    public static void move(List<Integer> A, List<Integer> B, List<Integer> C) {
        if (C.get(0) > A.get(A.size() - 1)) {
            C.add(A.remove(A.size() - 1));
        } else {
            while (C.size() > 0) {
                B.add(C.remove(C.size() - 1));
            }
            C.add(A.remove(A.size() - 1));
            while (B.size() > 0) {
                C.add(B.remove(B.size() - 1));
            }
        }
    }
}
```

## 稀疏数组

当一个数组中大部分元素为０，或者为同一个值的数组时，此时大多数的数据是重复的、无意义的，可以使用稀疏数组来保存该数组。

**处理方法**

- 记录数组一共有几行几列，有多少个不同的值，并把具有不同值的元素的行列及值记录在一个小规模的数组中

![](c:/notebook/pictures/Snipaste_2022-11-24_20-47-39.png =600x)

![](c:/notebook/pictures/Snipaste_2022-11-24_20-56-14.png =800x)

```java
package com.study01;

public class SparseArray {

	public static void main(String[] args) {
		// 原始的二维数组 11*11 （棋盘）
		// 0 没有棋子 ； 1 白子 ；2 黑子
		int[][] chessboardArr = new int[11][11];
		chessboardArr[1][1] = 1;
		chessboardArr[5][4] = 2;
		for (int[] chessArr : chessboardArr) {
			for (int chess : chessArr) {
				System.out.print(chess + "\t");
			}
			System.out.println();
		}

		// 转为稀疏数组：
		// 1. 先遍历二维数组，得到非大量重复的元素个数
		int sum = 0;
		for (int[] chessArr : chessboardArr) {
			for (int chess : chessArr) {
				if (chess != 0) {
					sum++;
				}
			}
		}
		// 2. 创建对应的稀疏数组，第一行留给统计行、列、不同值元素个数
		int[][] sparseArray = new int[sum + 1][3];
		sparseArray[0][0] = chessboardArr.length;
		sparseArray[0][1] = chessboardArr[0].length;
		sparseArray[0][2] = sum;
		int counter = 1;
		// 3. 给稀疏数组赋值
		for (int i = 0; i < chessboardArr.length; i++) {
			for (int j = 0; j < chessboardArr[i].length; j++) {
				if (chessboardArr[i][j] != 0) {
					sparseArray[counter][0] = i;
					sparseArray[counter][1] = j;
					sparseArray[counter][2] = chessboardArr[i][j];
					counter++;
				}
			}
		}

		for (int[] chessArr : sparseArray) {
			for (int chess : chessArr) {
				System.out.print(chess + "\t");
			}
			System.out.println();
		}

		// 稀疏数组-->原始二维数组
		// 1. 先读取稀疏数组的第一行，创建原始二维数组
		int[][] newChessboardArr = new int[sparseArray[0][0]][sparseArray[0][1]];
		// 2. 读取稀疏数组后几行的数据，并赋给原始二维数组 （如果需要可以先赋重复的、无意义的值）
		for (int i = 1; i < sparseArray.length; i++) {
			newChessboardArr[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
		}

		for (int[] chessArr : newChessboardArr) {
			for (int chess : chessArr) {
				System.out.print(chess + "\t");
			}
			System.out.println();
		}
	}

}
```

## 分治算法

- 分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。
- 将父问题分解为子问题同等方式求解，这和递归的概念很吻合，所以在分治算法通常以递归的方式实现(当然也有非递归的实现方式)。分治算法的描述从字面上也很容易理解，分、治其实还有个合并的过程：
   - 分(Divide)：递归解决子问题(到终止层或者可以解决的时候停下)
   - 治(Conquer)：递归求解，如果问题够小直接求解。 即：if条件
   - 合并(Combine)：将子问题的解构建父类问题    
- 一般分治算法在正文中分解为两个即以上的递归调用，并且子类问题一般是不想交的(互不影响)。当求解一个问题规模很大很难直接求解，但是规模较小的时候问题很容易求解并且这个问题并且问题满足分治算法的适用条件，那么就可以使用分治算法。

**使用时应满足的条件(特征)**

1. 原问题规模通常比较大，不易直接解决，但问题缩小到一定程度就能较容易的解决。
2. 问题可以分解为若干规模较小、求解方式相同(似)的子问题。且子问题之间求解是独立的互不影响。
3. 合并问题分解的子问题可以得到问题的解。

**具体应用**

1. 二分搜索
2. 快速排序
3. 归并排序（逆序数）
4. 最大子序列求和
5. 最近点对

### 寻找假币

- 从30个硬币中找到1个假币，假币的重量不同。

```java
package divide;

import java.util.Scanner;

public class CounterfeitCoin {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] arr = new int[30];
        int counteritCoin = Integer.parseInt(scanner.next());
        for (int i = 0; i < arr.length; i++) {
            if (i == counteritCoin) {
                arr[i] = 2;
            } else {
                arr[i] = 1;
            }
        }
        int index = find(arr, 0, arr.length - 1);
        System.out.println("假币(" + arr[index] + ")的位置：" + index);
    }

    public static int find(int[] coins, int start, int end) {
        if (start + 1 == end) { //终止条件
            return coins[start] > coins[end] ? start : end;
        }
        int startSum = 0, endSum = 0; //两段硬币的质量
        //计算两边重量
        //判断当前硬币数量的奇偶
        int mid = (start + end) / 2; //中间下标，若奇数：此时前半段比后半段多1个。
        if ((start - end + 1) % 2 == 0) { //偶数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }

            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        } else { //奇数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }
            //奇数0~4时：对于前半段：0~2 可能 3或4
            //对于后半段：3~4 可能 2或3 补充1 3或4 4或5
            endSum += coins[end]; //补充前半段多的。
            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        }
    }
}
```

## 概率算法

1. 将问题转化为相应的几何图形，其面积S，计算其占面积S的部分面积S1
2. 向几何图形中随机散点，统计S和S1中的点数，从而得到结果
3. 若未达到所需的精度，则继续执行步骤2的操作；到达则输出。

**常见**

1. 数值概率算法
2. 蒙特卡罗算法
3. 拉斯维加斯算法
4. 舍伍德算法

```java

```

## 动态规划算法
## 贪心算法
## 回溯法

### 8皇后

在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法?

```java

```

## 分治界限法

## 查询



## 排序

![](C:/notebook/pictures/Snipaste_2023-02-18_12-07-52.png =700x)

| 排序算法 | 平均时间复杂度 |   最好   |    最坏    | 空间复杂度 | 稳定性 |
| ------ | ----------- | ------- | --------- | --------- | ------ |
| 冒泡排序 | O(n^2)       | O(n)     | O(n^2)    | O(1)      | 稳定   |
| 快速排序 | O(nlogn)     | O(nlogn) | O(n^2)    | O(logn)   | 不稳定 |
| 插入排序 | O(n^2)       | O(n)     | O(n^2)    | O(1)      | 稳定   |
| 希尔排序 | O(n^1.3)     | O(n)     | O(nlog2n) | O(1)      | 不稳定 |
| 选择排序 | O(n^2)       | O(n^2)   | O(n^2)    | O(1)      | 不稳定 |
| 堆排序   | O(nlogn)     | O(nlogn) | O(nlogn)  | O(1)      | 不稳定 |
| 归并排序 | O(nlogn)     | O(nlogn) | O(nlogn)  | O(n)      | 稳定   |
| 桶排序   | O(n+k)       | O(n+k)   | O(n+k)    | O(n+k)    | 稳定   |
| 计数排序 | O(n+k)       | O(n+k)   | O(n+k)    | O(k)      | 稳定   |
| 基数排序 | O(n`*`k)     | O(n`*`k) | O(n`*`k)  | O(n+k)    | 稳定   |

### 交换类

#### 冒泡排序

- 冒泡排序是一种稳定排序算法，时间复杂度为O(n^2^).基本思想是：从前往后把大元素往后调(或者从后向前把小元素往前调)

![](c:/notebook/pictures/20200104104719116.gif =500x)

- 缺点是：一般最后一个数只能换一次位置

```java
package sort;

public class BubblingDemo {
    public static void main(String[] args) {
        double[] arr = {2, 3, 1};
        BubblingDemo bubblingDemo = new BubblingDemo();
        bubblingDemo.bubblingSort(arr); //2,1,3
    }

    public void bubblingSort(double[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    double temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
```

#### 快速排序

- 快排需要将序列变成两个部分，就是**序列左边全部小于一个数**，**序列右面全部大于一个数**，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是**通常**我们取最左边的那个数。

![](c:/notebook/pictures/Snipaste_2023-02-17_20-52-05.png =900x)
![](c:/notebook/pictures/Snipaste_2023-02-17_20-53-25.png =800x)
![](c:/notebook/pictures/Snipaste_2023-02-17_20-54-02.png =800x)

```java
package sort;

public class QuickSortDemo {
    public static void main(String[] args) {
        int[] arr = {2, 9, 2, 3, 7, 11, 4};
        quick(arr, 0, arr.length - 1);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void quick(int[] arr, int left, int right) {
        //选择排序的范围 下标
        int low = left;
        int high = right;

        //判断是否到达停止条件，是否越界
        if (low > high) {
            return;
        }

        int point = arr[low]; //额外空间，要求左边都小于他，同时右边都大于

        //完成一轮大小互换：将小于point的都放在左边，大于的放在右边
        while (low < high) {
            //找到的第一个小于point的则退出循环，并将该数覆盖arr[low]，即目前point所在的位置。
            //否则继续查找。
            while (low < high && arr[high] >= point) {
                high--;
            }
            arr[low] = arr[high];
            //找到的第一个大于point的则退出循环，并将该数覆盖arr[high]（此时的arr[high]在被覆盖前已经覆盖了之前的arr[low]）。
            //否则继续查找。
            while (low < high && arr[low] <= point) {
                low++;
            }
            arr[high] = arr[low];
        }

        //重置
        arr[low] = point;

        //将一轮大小互换之后的，继续按point分段再次排序，直到达到停止条件。 
        quick(arr, left, low - 1);
        quick(arr, low + 1, right);
    }
}
```

##### 双轴快排

- 单轴很多时候可能会遇到较差的情况就是当前元素可能是最大的或者最小的，这样子元素就没有被划分区间，快排的递推T(n)=T(n-1)+O(n)从而为O(n^2).
- 双轴就是选取两个主元素理想将区间划为3部分，这样不仅每次能够确定元素个数增多为2个，划分的区间由原来的两个变成三个，最坏最坏的情况就是左右同大小并且都是最大或者最小，但这样的概率相比一个最大或者最小还是低很多很多，所以双轴快排的优化力度还是挺大的。

**比privot1小的在privot1左侧，比privot2大的在privot2右侧，在privot1和privot2之间的在中间。**

![](c:/notebook/pictures/Snipaste_2023-02-17_22-05-27.png =800x)

**k交换过程**

![](c:/notebook/pictures/Snipaste_2023-02-17_22-10-37.png =800x)
![](c:/notebook/pictures/Snipaste_2023-02-17_22-11-12.png =800x)

**收尾工作**

![](c:/notebook/pictures/Snipaste_2023-02-17_22-12-20.png =800x)

```java
package sort;

public class DoubleQuickSortDemo {
    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 56, 72, 1, 2, 4, 3, 21};
        doubleQuick(arr, 0, arr.length - 1);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void doubleQuick(int arr[], int start, int end) {
        //非法参数直接停止
        if (start > end) {
            return;
        }

        //使picot1储存最左边的值，pivot2储存最右边的值，同时保证pivot1<pivot2。
        if (arr[start] > arr[end]) {
            swap(arr, start, end);
        }
        int pivot1 = arr[start];
        int pivot2 = arr[end];

        int left = start;
        int right = end;
        int k = left + 1;
        while (k < right) {
            if (arr[k] <= pivot1) {//左侧交换
                swap(arr, ++left, k++);
            } else if (arr[k] <= pivot2) { //中间值则跳过
                k++;
            } else { //右侧交换
                // 如果大于pivot2则继续查找，直到k
                while (arr[right] >= pivot2) {
                    if (right-- == k) {
                        break;
                    }
                }
                //如果超限，则停止
                if (k >= right) {
                    break;
                }
                //小于pivot2的与k位置互换
                swap(arr, k, right);
            }

            //
            swap(arr, start, left);
            swap(arr, end, right);

            //分段排序
            doubleQuick(arr, start, left - 1);
            doubleQuick(arr, left + 1, right - 1);
            doubleQuick(arr, right + 1, end);
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 插入类

#### 直接插入排序

- 直接插入排序遍历比较时间复杂度是每次O(n),交换的时间复杂度每次也是O(n),那么n次总共的时间复杂度就是O(n^2)。

![](C:/notebook/pictures/Snipaste_2023-02-18_12-11-44.png =800x)

```java
package sort;

public class DirectSortDemo {
    public static void main(String[] args) {
        int[] arr = {1, 6, 3, 2, 3, 4};
        directInsert(arr);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void directInsert(int[] arr) {
        int temp = 0;
        for (int i = 0; i < arr.length; i++) { //排序的位置
            temp = arr[i];
            for (int j = i - 1; j >= 0; j--) { //一轮排序
                if (arr[j] > temp) {
                    arr[j + 1] = arr[i];
                    arr[j] = temp;
                } else {
                    break;
                }
            }
        }
    }
}
```

#### 希尔排序

- 希尔排序就是以一种特殊的方式进行预处理，考虑到了**数据量和有序性**两个方面纬度来设计算法。使得序列前后之间小的尽量在前面，大的尽量在后面，进行若干次的分组别计算，最后一组即是一趟完整的直接插入排序。
- 对于一个`长串`，希尔首先将序列分割(非线性分割)而是**按照某个数模**(`取余`这个类似报数1、2、3、4。1、2、3、4)这样形式上在一组的分割先**各组分别进行直接插入排序**,这样**很小的数在后面**可以通过**较少的次数移动到相对靠前**的位置。然后慢慢合并变长，再稍稍移动。
- 因为每次这样插入都会使得序列变得更加有序，稍微有序序列执行直接插入排序成本并不高。所以这样能够在合并到最终的时候基本小的在前，大的在后，代价越来越小。这样希尔排序相比插入排序还是能节省不少时间的。

![](c:/notebook/pictures/Snipaste_2023-02-18_12-42-30.png =800x)

```java
public class HillTest {
    public static void hill(int[] arr) {
        for (int i = arr.length; i >= 1; i /= 2) { //分组排序
            for (int j = i; j < arr.length; j++) { 
                for (int k = j - i; k >= 0; k -= i) { //k和i之间保证始终相差i的倍数
                    if (arr[k] > arr[i]) {
                        int temp = arr[i];
                        arr[i] = arr[k];
                        arr[k] = temp;
                    }
                }
            }
        }
    }
}
```

### 选择类

#### 简单选择排序

 -首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到**已排序序列的末尾**。以此类推，直到所有元素均排序完毕。

```java
package sort;

public class SingleSelectSortDemo {
    public static void main(String[] args) {
        int[] arr = {1, 234, 45, 63, 2, 53, 6};
        selectSort(arr);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void selectSort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            int minIndex = i; //最小值相应的索引
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                int temp = arr[minIndex];
                arr[minIndex] = arr[i];
                arr[i] = temp;
            }
        }
    }
}

```

#### 堆排序

![](C:/notebook/pictures/Snipaste_2023-02-19_10-33-12.png =800x)

![](C:/notebook/pictures/Snipaste_2023-02-19_10-35-51.png =800x)
![](c:/notebook/pictures/Snipaste_2023-02-19_10-36-29.png =800x)

```java
package sort;

import java.util.Arrays;

public class HeadSortDemo {
    public static void main(String[] args) {
        heapSort(new int[]{1, 2, 9, 5, 7, 2, 34, 24, 0, 5, 3, 2});
    }

    public static void shiftDown(int[] arr, int curIndex, int length) {
        //获取子结点的坐标
        int leftIndex = curIndex * 2 + 1;
        int rightIndex = curIndex * 2 + 2;
        //比较结点大小并交换：使得右子结点>左子结点>当前结点 小根堆
        //因为是使用数组储存，所以下标为0~length-1
        if (leftIndex >= length) {//判断是否超过范围，即当前结点是否为叶子结点
            return;
        } else if (rightIndex < length && arr[rightIndex] < arr[curIndex] && arr[rightIndex] < arr[leftIndex]) { //判断是否存在右子结点，以及比较结点大小
            int temp = arr[rightIndex];
            arr[rightIndex] = arr[curIndex];
            arr[curIndex] = temp;
            shiftDown(arr, rightIndex, length);
        } else if (arr[leftIndex] < arr[curIndex]) {
            int temp = arr[leftIndex];
            arr[leftIndex] = arr[curIndex];
            arr[curIndex] = temp;
            shiftDown(arr, leftIndex, length);
        }
    }

    public static void createHeap(int[] arr) {
        //排序为小根堆
        for (int i = arr.length / 2; i >= 0; i--) {
            //arr.length / 2 堆的非叶子结点数 = 堆的总长度 / 2
            shiftDown(arr, i, arr.length);
        }
    }

    public static void heapSort(int arr[]) {
        int[] tempArr = new int[arr.length]; //临时存放结果的空数组
        createHeap(arr);
        //将（小根堆）堆顶元素放入tempArr，依次将末尾元素置为堆顶
        for (int i = 0; i < arr.length; i++) {
            tempArr[i] = arr[0];
            arr[0] = arr[arr.length - 1 - i];
            shiftDown(arr, 0, arr.length - i);
        }
        //将排序好的结果放入arr中
        for (int i = 0; i < arr.length; i++) {
            arr[i] = tempArr[i];
        }
        System.out.println("堆排序：" + Arrays.toString(arr));
    }
}
```

### 归并排序

- 时间复杂度为O(nlogn).
- 归并排序是基于分治进行归并的，有**二路归并**和多路归并。日常用的基本是二路归并。并且**归并排序的实现方式**有`递归形式`和`非递归形式`。
   - 非递归的过程就是`局部—>整体`的过程，而递归是`整体—>局部—>整体`的过程 
- 应用是求序列中的逆序数个数。当然**逆序数也可以用树状数组**完成


![](c:/notebook/pictures/Snipaste_2023-02-19_17-31-05.png =800x)

```java
package sort;

import java.util.Arrays;

public class MegerSortDemo {
    public static void main(String[] args) {
        int[] arr = {12, 32, 4, 42, 3, 53, 224, 34, 5, 32, 3};
        mergeSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    public static void mergeSort(int[] arr, int left, int right) {
        int mid = (left + right) / 2; //分为左右两个区间进行分治
        if (left < right) {
            mergeSort(arr, left, mid); //处理左区间
            mergeSort(arr, mid + 1, right); //处理右区间
            merge(arr, left, mid, right); //合并
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int leftIndex = left, rightIndex = mid + 1; //分别对mid左边和右边进行处理
        int[] tempArr = new int[right - left + 1]; //临时存放的空数组
        int tempIndex = 0;
        //进行排序，从小到大
        while (leftIndex <= mid && rightIndex <= right) {
            if (arr[leftIndex] <= arr[rightIndex]) {
                tempArr[tempIndex++] = arr[leftIndex++];
            } else {
                tempArr[tempIndex++] = arr[rightIndex++];
            }
        }
        //对剩下越界的分别进行赋值，加入到tempArr的末尾
        while (leftIndex <= mid) {
            tempArr[tempIndex++] = arr[leftIndex++];
        }
        while (rightIndex <= right) {
            tempArr[tempIndex++] = arr[rightIndex++];
        }
        //将排序好的tempArr重新赋值给arr相应下标范围
        for (int i = 0; i < tempIndex; i++) {
            arr[left + i] = tempArr[i];
        }
    }
}
```

#### 逆序数

- 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对
   - 比如`3 2 1`.看3 ，有2 1在后面，看2 有1在后面有`3`个逆序数 
- 变化过程只需要注意一些相对变化即可也就是把每个归并的过程逆序数发生变化进行累加，那么最终有序的那个序列为止得到的就是整个序列的逆序数
   - 可以发现每次归并过程中，当且仅当右侧的数提前放到左侧，而左侧还未放置的个数就是该元素减少的逆序个数
   
```java
package sort;

import java.util.Arrays;

public class InversionNumberDemo {
    public static void main(String[] args) {
        int[] arr = {2,8,1,3,7,4,5,0};
        InversionNumberDemo inversionNumberDemo = new InversionNumberDemo();
        System.out.println(inversionNumberDemo.getInversionNumber(arr, 0, arr.length - 1));
        System.out.println(Arrays.toString(arr));
    }

    public int getInversionNumber(int[] arr, int left, int right) {
        if (left > right && right < 2) {
            return 0;
        }

        int mid = (left + right) / 2;
        int countAll = 0, countLeft = 0, countRight = 0;

        if (left < right) {
            countLeft += getInversionNumber(arr, left, mid);
            countRight += getInversionNumber(arr, mid + 1, right);
            countAll += merge(arr, left, mid, right);
        }
        return countAll + countLeft + countRight;
    }

    public int merge(int[] arr, int left, int mid, int right) {
        int count = 0;
        int leftIndex = left, rightIndex = mid + 1;
        int[] tempArr = new int[right - left + 1];
        int tempIndex = 0;

        while (leftIndex <= mid && rightIndex <= right) {
            if (arr[leftIndex] < arr[rightIndex]) {
                tempArr[tempIndex++] = arr[leftIndex++];
            } else if (arr[leftIndex] == arr[rightIndex]) {
                tempArr[tempIndex] = arr[rightIndex++];
                count += mid - leftIndex;
            } else {
                tempArr[tempIndex++] = arr[rightIndex++];
                count += mid - leftIndex + 1;
            }
        }

        while (leftIndex <= mid) {
            tempArr[tempIndex++] = arr[leftIndex++];
        }
        while (rightIndex <= right) {
            tempArr[tempIndex++] = arr[rightIndex++];
        }

        for (int i = 0; i < tempArr.length; i++) {
            arr[left + i] = tempArr[i];
        }
        return count;
    }
}
```

### 桶类

#### 桶排序

- **将待排序的序列分到若干个桶中，每个桶内的元素再进行个别排序。** 
- 时间复杂度最好可能是线性O(n)，桶排序不是基于比较的排序，**桶排序是一种用空间换取时间的排序。**

![](C:/notebook/pictures/Snipaste_2023-02-19_20-40-14.png =900x)

- **假设每个桶内部使用的排序算法为快速排序**，那么每个桶内的时间复杂度为`(n/m) log(n/m)`。有m个桶，那么时间复杂度为`m * (n/m)log(n/m)`=`n (log n-log m)`.所以最终桶排序的时间复杂度为：`O(n)+O(n*(log n- log m))`=`O(n+n*(log n -log m))` 其中m为桶的个数。我们有时也会写成O(n+c),其中c=n*(log n -log m);

```java
package sort;

import java.util.ArrayList;
import java.util.List;

public class BucketSortDemo {
    public static void main(String[] args) {
        int[] arr = {2,23,3,4,5,16,42,13,12,24,45,34,23,34};
        bucketSort(arr);
    }

    public static void bucketSort(int[] arr) {
        List[] bukects = new ArrayList[5]; //使用5个桶 List
        //初始化桶
        for (int i = 0; i < bukects.length; i++) {
            bukects[i] = new ArrayList<Integer>();
        }
        //将待排序序列放入桶中
        for (int i = 0; i < arr.length; i++) {
            int index = arr[i] / 10; // 入桶的规则
            bukects[index].add(arr[i]);
        }
        //每个桶内部排序
        for (int i = 0; i < bukects.length; i++) {
            bukects[i].sort(null); //快排
            for (int j = 0; j < bukects[i].size(); j++) {
                System.out.println(bukects[i].get(j) + " ");
            }
        }
    }
}
```

#### 计数排序

- 计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为`Ο(n+k)`（其中k是整数的范围），快于任何比较排序算法。   当然这是一种牺牲空间换取时间的做法，而且当`O(k)>O(n*log(n))`的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是`O(n*log(n))`, 如归并排序，堆排序）
- 当数据范围波动不是很大，数据相对比较集中，即最大值和最小值相差不大的。

![](c:/notebook/pictures/20200808091520863.gif =800x)

```java
package sort;

public class CountSortDemo {
    public static void count(int[] arr) {
        //存放最小值和最大值
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
            if (arr[i] > max) {
                max = arr[i];
            }

        }
        //桶内计数：count[] 内存放的是该数存在的次数
        int count[] = new int[max - min + 1]; //计算出桶的数量为：max - min + 1；对每个数放一个桶
        for (int i = 0; i < arr.length; i++) {
            count[arr[i] - min]++; //相应下标的数的个数增加
        }
        //将计数排序的放入arr原数组
        int index = 0; //放入arr时的下标
        for (int i = 0; i < count.length; i++) {
            while (count[i]-- > 0) { //存在1个以上的该数，则依次取出放入原数组arr
                arr[index++] = i + min; //
            }
        }
    }
}
```

#### 基数排序

- 基数排序也称为卡片排序，简而言之，基数排序的原理就是多次利用计数排序(计数排序是一种特殊的桶排序)，但是和前面的普通桶排序和计数排序有所区别的是，基数排序并不是将一个整体分配到一个桶中，而是将自身拆分成一个个组成的元素，每个元素分别顺序分配放入桶中、顺序收集，当从前往后或者从后往前每个位置都进行过这样顺序的分配、收集后，就获得了一个有序的数列。
- 在具体实现上如果从左往右那就是**最高位优先(Most Significant Digit first)法**，简称MSD法；如果从右往左那就是**最低位优先(Least Significant Digit first)法**，简称LSD法。但是不管从最高位开始还是从最低位开始要保证和相同位进行比较，你需要注意的是如果是int等数字类型需要保证从右往左(从低位到高位)保证对齐，如果是字符类型的话需要从左往右(从高位到低位)保证对齐。如：557、23、7532、239、"cet"、"pi"、"bigs"、"ace"。

![](c:/notebook/pictures/Snipaste_2023-02-20_00-38-08.png =800x)

- 一方面基数排序可能很多时候处理的是字符型的数据，不方便放入某个桶中，另一方面如果数字很大，不方便直接放入桶中。并且基数排序并不需要交换，也不需要比较，就是多次分配、收集得到结果。

![](c:/notebook/pictures/Snipaste_2023-02-20_10-17-57.png =800x)
![](c:/notebook/pictures/Snipaste_2023-02-20_10-19-03.png =700x)

##### 数字类型

- 无论是最高位优先法还是最低位优先法进行遍历需要保证数字各位、十位、百位等对齐，这里我使用最低位优先法从个位开始向上。
- 数字类型的基数排序需要十个桶(0-9)，如果使用二维数组，第一维度长度为10表示十个数字，第二个维度为数组长度，用来存储数字(因为最坏情况可能当前位数字一样)，浪费内存空间极其严重。可以使用List或者Queue替代，这里就用List了。
- 具体实现要先找到最大值确定最高多少位，用来进行遍历时候确认。
- 收集的时候借助一个自增参数遍历收集。
- 每次收集完毕十个桶(bucket)需要清空待下次收集。

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,34,342,3423,34,23,34,12,4445,234};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void cardinal(int[] arr) {
        //桶
        List<Integer>[] bukects = new ArrayList[10]; //0~9
        for (int i = 0; i < bukects.length; i++) {
            bukects[i] = new ArrayList<Integer>();
        }

        int max = Integer.MIN_VALUE; //最大值 用于确定while循环的最大次数
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int divideNum = 1; //分割对应位的数字 1、10、100、...
        while (max > 0) {
            for (int i = 0; i < arr.length; i++) {
                bukects[(arr[i] / divideNum) % 10].add(arr[i]);
            }
            divideNum *= 10; //计算位数
            max /= 10; //计算循环次数
            int index = 0;
            for (int i = 0; i < bukects.length; i++) {
                for (int j = 0; j < bukects[i].size(); j++) {
                    arr[index++] = bukects[i].get(j);
                }
                bukects[i].clear(); //清空，等待下个位的数字使用
            }
        }
    }
}
```

##### 等长字符串

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortEqualStringDemo {
    public static void main(String[] args) {
        String[] arr = {"asda", "hscs", "1122", "+12s", "aacs"};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void cardinal(String[] arr) {
        List<String>[] buckets = new ArrayList[128]; //ASCII码对应
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = new ArrayList<>();
        }
        int length = arr[0].length(); //等长字符串
        int temp = length;
        while (length > 0) {
            for (int i = 0; i < arr.length; i++) {
                buckets[arr[i].charAt(temp - length)].add(arr[i]);
            }
            int index = 0;
            for (int i = 0; i < buckets.length; i++) {
                for (int j = 0; j < buckets[i].size(); j++) {
                    arr[index++] = buckets[i].get(j);
                }
                buckets[i].clear();
            }
            length--;
        }
    }
}
```

###### 空间优化

##### 非等长字符串

![](c:/notebook/pictures/Snipaste_2023-02-20_13-09-48.png =1000x)
![](c:/notebook/pictures/Snipaste_2023-02-20_13-10-37.png =1000x)

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortStringDemo {
    public static void main(String[] args) {
        String[] arr = {"asda", "23wad", "asxcs", "sad", "dvea", "=d", "bs"};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void cardinal(String[] arr) {
        int maxLength = -1; //最长的字符串
        for (String str : arr) {
            if (maxLength < str.length())
                maxLength = str.length();
        }
        //先进行一次按长度的基数排序
        List<String>[] lengthBuckets = new ArrayList[maxLength + 1]; //由长度分桶
        for (int i = 0; i < lengthBuckets.length; i++) {
            lengthBuckets[i] = new ArrayList<String>();
        }
        for (String str : arr) {
            lengthBuckets[str.length()].add(str);
        }
        int index = 0;
        for (List<String> lengthBucket : lengthBuckets) {
            for (String str : lengthBucket) {
                arr[index++] = str;
            }
        }
        //重新利用字符来装桶 此时的arr已经按照长度从短到长排序
        List<String>[] wordBuckets = new ArrayList[128]; //由字符来分桶
        for (int i = 0; i < wordBuckets.length; i++) {
            wordBuckets[i] = new ArrayList<String>();
        }
        int startIndex = arr.length;
        for (int i = maxLength; i > 0; i--) {//按照长度进行相应的等长字符基数排序
            startIndex -= lengthBuckets[i].size(); //确定循环的次数
            for (int j = startIndex; j < arr.length; j++) {
                wordBuckets[arr[j].charAt(i - 1)].add(arr[j]);
            }
            index = startIndex;
            for (List<String> wordBucket : wordBuckets) {
                for (String str : wordBucket) {
                    arr[index++] = str;
                }
                wordBucket.clear();
            }
        }
    }
}
```

### 拓扑排序

# 设计模式

- 创建型模式，共五种：
   - 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
- 结构型模式，共七种：
   - 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式，共十一种：
   - 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

**设计模式的六大原则**

1. 开闭原则（Open Close Principle）
   - 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。
2. 里氏代换原则（Liskov Substitution Principle）
   - 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3. 依赖倒转原则（Dependence Inversion Principle）
   - 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4. 接口隔离原则（Interface Segregation Principle）
   - 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5. 迪米特法则（最少知道原则）（Demeter Principle）
   - 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6. 合成复用原则（Composite Reuse Principle）
   - 原则是尽量使用合成/聚合的方式，而不是使用继承。

## 工厂模式

**分类**

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

**使用背景**

- 编码时不能预见需要创建哪种类的实例。
- 系统不应依赖于产品类型实例如何被创建、组合和表达的细节。

### 简单工厂模式（静态工厂模式）

**组成**

1. 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。
2. 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。
    - 优先接口
    - 使用抽象类：在要定义子类的行为，且为子类提供公共的功能时。
3. 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。

![](c:/notebook/pictures/Snipaste_2022-11-20_00-24-57.png =350x)

![](c:/notebook/pictures/Snipaste_2022-11-21_18-51-33.png =600x)

**获取实例方法的写法**

1. 对不同的具体类，添加不同的获取方法。
     - 违背OCP原则
2. 配置文件
3. 反射


### 工厂方法模式

- 抽象对抽象，具体对具体

![](c:/notebook/pictures/Snipaste_2022-11-21_18-58-01.png =650x)

**实现**


- 产品

```java
package factory.methodFactory;

public interface Fruit {
}

class Apple implements Fruit {

}

class Banana implements Fruit {

}
```

- 工厂

```java
package factory.methodFactory;

public interface FruitFactory {
    public Fruit makeFruit();
}

class AppleFactory implements FruitFactory {

    @Override
    public Fruit makeFruit() {
        return new Apple();
    }
}

class BananaFactory implements FruitFactory {

    @Override
    public Fruit makeFruit() {
        return new Banana();
    }
}
```

### 抽象工厂模式

- 每个具体工厂生产一个产品族（相关/依赖的一系列产品），产品族内包含不同等级的产品。
   - 如：Intel、Amd分别为一个产品族，而CPU、主板、硬盘等分别属于不同等级的产品。
   
![](c:/notebook/pictures/ =600x)

**使用场景**

- 产品有多个产品族，而只消费其中某一族的产品
- 同属于同一族的产品必须一起使用
- 系统提供一个产品类的库，所有的产品以相同的接口出现

**实现**

- 产品CPU

```java
public interface CPU {
}

class IntelCPU implements CPU {
    public static final int PORT = 1001;
}

class AmdCPU implements CPU {
    public static final int PORT = 1002;
}
```

- 产品MainBoard

```java
public interface MainBoard {
}

class IntelMainBoard implements MainBoard {
    public static final int PORT = 1001;
}

class AmdMainBoard implements MainBoard {
    public static final int PORT = 1002;
}
```

- 工厂

```java
public interface ComputerFactory {
    CPU createCPU();

    MainBoard createMainBoard();
}

class IntelFactory implements ComputerFactory {

    @Override
    public CPU createCPU() {
        return new IntelCPU();
    }

    @Override
    public MainBoard createMainBoard() {
        return new IntelMainBoard();
    }
}

class AmdFactory implements ComputerFactory {

    @Override
    public CPU createCPU() {
        return new AmdCPU();
    }

    @Override
    public MainBoard createMainBoard() {
        return new AmdMainBoard();
    }
}
```

- 客服端

```java
import factory.simpleFactory.ACloth;

public class Client {
    public static void main(String[] args) {
        IntelFactory intelFactory = new IntelFactory();
        makeComputer(intelFactory);
    }

    public static void makeComputer(ComputerFactory factory) {
        if (factory instanceof IntelFactory) {
            IntelCPU cpu = (IntelCPU) factory.createCPU();
            IntelMainBoard mainBoard = (IntelMainBoard) factory.createMainBoard();
        }
        if (factory instanceof AmdFactory) {
            AmdCPU cpu = (AmdCPU) factory.createCPU();
            AmdMainBoard mainBoard = (AmdMainBoard) factory.createMainBoard();
        }
    }
}
```

## 单例模式

**特点**

- 该类只有一个实例
- 该类自行创建实例，在类的内部创建自身的实例对象
- 向整个系统公开这个实例接口

**实现**

- 将构造器设为`private`，同时将自身的实例对象属性设为`private static`，只能通过该类定义的静态方法`getInstance()`方法获取实例

### 饿汉式

```java
public class Singleton {

    private static Singleton instance = new LazySingleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

### 懒汉式

```java
public class LazySingleton {
    private static LazySingleton instance = null;

    private LazySingleton() {
    }

    public synchronized static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```



### 登记式

- 静态工厂方法，返回指定登记对象的一个实例
- 对于已登记的直接取出返回；对于还未登记的，先登记再返回
- 继承该类的子类可以通过该模式，获取各自的单例

```java
import java.util.HashMap;
import java.util.Map;

public class RegSingleton {

    private static Map<String, RegSingleton> mRegistry = new HashMap();

    static {
        RegSingleton regSingleton = new RegSingleton();
        mRegistry.put(regSingleton.getClass().getName(), regSingleton);
    }

    protected RegSingleton() {
    }

    public RegSingleton getInstance(String name) {
        if (name == null) {
            name = "RegSingleton";
        }

        if (mRegistry.get(name) == null) {
            try {
                mRegistry.put(name, (RegSingleton) Class.forName(name).newInstance());
            } catch (InstantiationException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }

        return mRegistry.get(name);
    }
}
```

### 更好的实现

#### 双重检查加锁

- 减少懒汉式线程安全对访问速度的影响。

```java
public class Singleton {
    private volatile static Singleton instance = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        //检查instance是否为null
        if (instance == null) {
            synchronized (Singleton.class) {
                //再次检查instance是否为null
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 延迟加载

#### 内部类的静态构造器

- 由JVM来保证线程安全，并实现延迟加载

```java
package singleton;

public class StaticSingleton {
    //通过内部类的静态构造器创建单例，通过JVM保证线程安全
    private static class SingletonHolder{
        private static StaticSingleton instance = new StaticSingleton();
    }

    private StaticSingleton(){
    }

    //只要不调用该方法，内部类的静态构造器就不会被调用，保证延迟加载
    public static StaticSingleton getInstance(){
        return SingletonHolder.instance;
    }
}
```

#### 枚举实现单例模式

- 更加简洁，且由JVM保证单例

```java
public enum SingletonEnum {
    uniqueInstance;
}
```

## 建造者模式

**组成**

- 客户端：只需与指导者交互即可。
- 指导者：与客户端联系，并告诉建造者应该建造的产品，调用具体建造者中的方法。
- 建造者
   - 抽象建造者：为产品对象的各个部件指定抽象接口，返回复杂对象
   - 具体建造者 ：实现各个部件的具体构造装配，返回复杂对象
- 产品

![](c:/notebook/pictures/Snipaste_2022-11-26_15-18-28.png =700x)

**实现**

![](c:/notebook/pictures/Snipaste_2022-11-26_15-59-54.png =600x)

- 产品

```java
package builderTest;

public class Product {
    //部件
    private String partA;
    private String partB;
    private String partC;

    public void setPartA(String partA) {
        this.partA = partA;
    }
    public void setPartB(String partB) {
        this.partB = partB;
    }
    public void setPartC(String partC) {
        this.partC = partC;
    }

    public String getPartA() {
        return partA;
    }
    public String getPartB() {
        return partB;
    }
    public String getPartC() {
        return partC;
    }
}
```

- 抽象建造者

```java
package builderTest;

public interface Builder {
    //组件的建造
    public abstract void makePartA();
    public abstract void makePartB();
    public abstract void makePartC();
    //返回复杂对象
    public abstract Product getProduct();
}
```

- 具体建造者

```java
package builderTest;

public class ProductABuilder implements Builder{
    Product productA = new Product();

    @Override
    public void makePartA() {
        productA.setPartA("productA-partA");
    }

    @Override
    public void makePartB() {
        productA.setPartB("productA-partB");
    }

    @Override
    public void makePartC() {
        productA.setPartC("productA-partC");
    }

    @Override
    public Product getProduct() {
        return productA;
    }
}
```

- 指导者

```java
package builderTest;

public class Director {
    //指导建造者制作组件
    public void makeProduct(Builder builder){
        builder.makePartA();
        builder.makePartB();
        builder.makePartC();
    }
}
```

- 客户端

```java
package builderTest;

public class User {
    public static void main(String[] args) {
        ProductABuilder productABuilder = new ProductABuilder();
        Director director = new Director();
        director.makeProduct(productABuilder);
        Product productA = productABuilder.getProduct();
        System.out.println(productA + "[" + productA.getPartA() + "|" + productA.getPartB() + "|" + productA.getPartC() + "]");
    }
}
```

## 原型模式

- 通过复制原型对象来创建更多同类型的对象
- 相似但不相同：通过复制方法创建的对象是新的对象，在内存中拥有新的地址，每个复制的对象相互独立。在对复制的对象修改时，不会影响原型对象。

![](c:/notebook/pictures/Snipaste_2022-11-26_18-21-17.png =600x)

### 实现

#### 通用实现方法

![](c:/notebook/pictures/Snipaste_2022-11-26_18-27-51.png =600x)

#### clone()实现方法

- 重写java.lang.Object中的clone()方法
- 必须是实现了Cloneable接口的类才可以使用该clone()方法
  - 否则：CloneNotSupportException 

**注意：**

![](c:/notebook/pictures/Snipaste_2022-11-26_18-31-49.png =600x)

**实现**

![](c:/notebook/pictures/Snipaste_2022-11-26_18-34-00.png =400x)

```java
package cloneTest;

public class ConcretePrototype implements Cloneable{
    private int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    protected ConcretePrototype clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        return (ConcretePrototype) obj;
    }
}
```

```java
package cloneTest;

public class Test {
    public static void main(String[] args) {
        ConcretePrototype prototype1 = new ConcretePrototype();
        prototype1.setId(1001);
        System.out.println(prototype1 +"-" + prototype1.getId());
        try {
            ConcretePrototype prototype2 = prototype1.clone();
            System.out.println(prototype2 +"-" + prototype2.getId());
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        //cloneTest.ConcretePrototype@1b2c6ec2-1001
        //cloneTest.ConcretePrototype@4edde6e5-1001
    }
}
```

### 浅拷贝与深拷贝

- 浅拷贝：被拷贝对象的所有属性都和原型对象相同，包括其属性对象的地址还是原来的地址。                                          
- 深拷贝：被拷贝对象的所有属性都和原型对象相同，但其属性对象被赋予新的地址 。

**注：**

- String类型的属性，尽管没有实现Cloneable接口的clone()方法，但是可以看作基本数据类型一般被拷贝。与其他的类属性不同。而StringBuffer不行
- 对象拷贝时，没有使用构造器方法，而是从堆内存中以二进流的方式进行拷贝，重新分配一个内存块。因此，当需要使用多个new对象时，使用clone()方法可以减少资源的占用。


**在浅拷贝的基础上实现深拷贝：**

- 深拷贝的类属性的类也要实现Cloneable接口

```java
package cloneTest;

public class Pet implements Cloneable {
    private String kind;
    private int age;

    public Pet() {
    }

    public Pet(String kind, int age) {
        this.kind = kind;
        this.age = age;
    }

    @Override
    protected Pet clone() throws CloneNotSupportedException {
        Pet pet = (Pet) super.clone();
        return pet;
    }
}
```

```java
package cloneTest;

public class Person implements Cloneable {
    private String name;
    private int age;
    private Pet pet;

    public Person() {

    }

    public Person(String name, int age, Pet pet) {
        this.name = name;
        this.age = age;
        this.pet = pet;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Pet getPet() {
        return pet;
    }

    public void setPet(Pet pet) {
        this.pet = pet;
    }

    //浅拷贝
//    @Override
//    protected Person clone() throws CloneNotSupportedException {
//        Object obj = super.clone();
//        return (Person) obj;
//    }
    //深拷贝
    @Override
    protected Person clone() throws CloneNotSupportedException {
        Person person = (Person) super.clone();
        person.setPet(this.getPet().clone());
        return person;
    }
}
```

- 浅拷贝

```java
@Test
public void test1() {
    Person p1 = new Person("Tom", 12, new Pet("Dog", 4));
    System.out.println(p1 + "-" + p1.getPet());
    try {
        Person p2 = p1.clone();
        System.out.println(p2 + "-" + p2.getPet());
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
    //浅拷贝，拷贝对象的类属性的地址仍然相同 cloneTest.Pet@3d36e4cd
    //cloneTest.Person@709ba3fb-cloneTest.Pet@3d36e4cd
    //cloneTest.Person@6a472554-cloneTest.Pet@3d36e4cd
}
```

- 深拷贝

```java
@Test
public void test2() {
    Person p1 = new Person("Tom", 12, new Pet("Dog", 4));
    System.out.println(p1 + "-" + p1.getPet());
    try {
        Person p2 = p1.clone();
        System.out.println(p2 + "-" + p2.getPet());
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
    //深拷贝，拷贝对象的类属性的地址不再相同
    //cloneTest.Person@3d36e4cd-cloneTest.Pet@6a472554
    //cloneTest.Person@7ff2a664-cloneTest.Pet@525b461a
}
```

#### 序列化实现

```java
package cloneTest;

import java.io.*;

public class ObjectCloneDemo {
    public static void main(String[] args) {
        ObjectClone obj1 = new ObjectClone(1001, "Tom");
        ObjectClone objClone1 = obj1.deepClone();
        System.out.println(obj1);
        System.out.println(objClone1);
    }
}

class ObjectClone implements Cloneable, Serializable {
    private int id;
    private String name;

    public ObjectClone() {
    }

    public ObjectClone(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "ObjectClone{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return (ObjectClone) super.clone();
    }

    public ObjectClone deepClone() {
        ByteArrayOutputStream bao = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try {
            bao = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bao);
            oos.writeObject(this);
            bis = new ByteArrayInputStream(bao.toByteArray());
            ois = new ObjectInputStream(bis);
            return (ObjectClone) ois.readObject();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if (ois != null)
                    ois.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            if (bis != null)
                try {
                    bis.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            if (oos != null)
                try {
                    oos.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            if (bao != null)
                try {
                    bao.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
        }
    }
}
```

## 适配器模式

- 当使用一个已经存在的类时，其接口不符合要求时；创建一个可以复用的类，与其他不相关的/不可预见的类协同工作，用来适配它们的父类接口。

**分类**

| 类型            | 实现        | 说明                                                   |
| :-------------- | :--------- | :----------------------------------------------------- |
| 类的适配器模式   | extends    | 单一源适配，清晰                                        |
| 对象的适配器模式 | implements | 多源适配，但不太清晰                                     |
| 默认适配器模式   | 抽象类      | 只需实现一部分目标接口的方法（即Swing中的事件类的Adapter） |

![](c:/notebook/pictures/Snipaste_2022-12-06_13-43-24.png =500x)

```java
package cloneTest;

public class AdapterDemo {
    public static void main(String[] args) {
        Target target = new Adapter();
        int v1 = target.get110v();
        int v2 = target.get220v();
    }
}

//源角色： 需要被适配
class Adaptee {
    public int get220v() {
        return 220;
    }
}

//目标抽象角色： 所有需要转换的接口的抽象
interface Target {
    int get110v();

    int get220v();
}

//适配器 适配于源角色，提供新的方法
class Adapter extends Adaptee implements Target {
    @Override
    public int get110v() {
        return 110;
    }
}
```

```java
package cloneTest;

public class AdapterDemo2 {
    public static void main(String[] args) {
        //类的适配器实现
        Language language01 = new Adapter01();
        language01.speakEnglish();
        //对象的适配器实现
        Human human02 = new Human();
        Language langeuage02 = new Adapter02(human02);
        langeuage02.speakEnglish();
        //默认适配器实现
        Language langeuage03 = new LanguageImpl();
        langeuage03.speakEnglish();
    }
}

class Human {
    private String name, sex;

    public void speakChinese() {
        System.out.println("Chinese");
    }
}

interface Language {
    void speakEnglish();

    void speakChinese();
}

//类的适配器模式
class Adapter01 extends Human implements Language {
    @Override
    public void speakEnglish() {
        System.out.println("English-Adapter01");
    }
}

//对象的适配器模式
class Adapter02 implements Language {
    //对象
    private Human human;

    public Adapter02(Human human) {
        this.human = human;
    }

    @Override
    public void speakEnglish() {
        System.out.println("English-Adapter02");
    }

    @Override
    public void speakChinese() {
        System.out.println("Chinese");
    }

    public Human getHuman() {
        return human;
    }

    public void setHuman(Human human) {
        this.human = human;
    }
}

//默认适配器模式
//抽象类用来实现Language接口中的所有方法
abstract class LanguageDefault implements Language {
    @Override
    public void speakChinese() {
    }

    @Override
    public void speakEnglish() {
    }
}

//实现类，选择部分需要的实现即可
class LanguageImpl extends LanguageDefault {

    //这里只需要English，故只覆盖speakEnglish()方法
    @Override
    public void speakEnglish() {
        System.out.println("English-Default");
    }
}
```

## 桥梁模式 （柄体/接口模式）

- 将抽象化与实现脱耦

![](c:/notebook/pictures/Snipaste_2022-12-06_14-42-56.png =500x)

| 角色          | 等级   |                                                                                                                                         |
| :------------ | :----- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| 抽象化角色     | 抽象化 | 抽象化给出的定义，并保存一个对实现化角色的引用                                                                                              |
| 修正抽象化角色 | 抽象化 | 扩展抽象化角色，改变和修正父类对抽象化的定义                                                                                                |
| 实现化角色     | 实现化 | 给出实现化角色的接口，当不给出具体的实现。不一定与抽象化角色的接口定义相同。实现化角色只给出底层操作，而抽象化角色只给出基于底层操作的更高一层操作。 |
| 具体实现化角色 | 实现化 | 对实现化角色的具体实现                                                                                                                                      |

- 抽象化等级结构中的方法通过向对应的实现化对象委派实现自己的功能。即抽象化角色可以通过向不同的实现化对象委派，而动态的转换自己的功能。

```java
public class InterfaceTest {
}

//抽象化角色
abstract class Abstraction {
    //对实现化角色的引用
    protected Implementor impl;

    public Abstraction(Implementor impl) {
        this.impl = impl;
    }

    public void operation() {
        impl.operationImpl();
    }
}

//抽象修正角色
class RefindAbstraction extends Abstraction {
    public RefindAbstraction(Implementor impl) {
        super(impl);
    }

    //其他的操作方法
    public void otherOperation() {
    }
}

//实现化角色
abstract class Implementor {
    public abstract void operationImpl();
}

//具体实现化角色
class ConreteImplementorA extends Implementor {
    @Override
    public void operationImpl() {
        //具体操作
    }
}
class ConreteImplementorB extends Implementor {
    @Override
    public void operationImpl() {
        //具体操作
    }
}
```

### 实现


**普通**

![](C:/notebook/pictures/Snipaste_2022-12-06_15-18-33.png =500x)

**桥接模式**

![](c:/notebook/pictures/Snipaste_2022-12-06_15-16-59.png =400x)

![](c:/notebook/pictures/Snipaste_2022-12-06_15-18-16.png =500x)

```java
package interfaceTest;

public class InterfaceTest02 {
    public static void main(String[] args) {
        //以SMS发送普通消息
        AbstartMessage message = new CommonMessage(new MessageSMS());
        message.sendMessage("信件内容", "Tom");
        //以Email发送加急消息
        message = new UrgentMessage(new MessageEmail());
        message.sendMessage("信件内容", "Tom");
    }
}

//抽象化角色
abstract class AbstartMessage {
    MessageImplementor impl;

    public AbstartMessage(MessageImplementor impl) {
        this.impl = impl;
    }

    public void sendMessage(String message, String toUser) {
        this.impl.send(message, toUser);
    }
}

//实现化角色
interface MessageImplementor {
    public void send(String message, String toUser);
}

//具体实现角色
//以站内短消息的方式发送
class MessageSMS implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("SMS-[" + message + "]-TO-" + toUser);
    }
}

//以E-mail的方式发送
class MessageEmail implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("Email-[" + message + "]-TO-" + toUser);
    }
}

//抽象修正角色
//扩展抽象的消息接口
//普通消息
class CommonMessage extends AbstartMessage {
    public CommonMessage(MessageImplementor impl) {
        super(impl);
    }

    //对于普通消息直接调用父类的，不改变
    @Override
    public void sendMessage(String message, String toUser) {
        super.sendMessage(message, toUser);
    }
}

//加急消息
class UrgentMessage extends AbstartMessage {
    public UrgentMessage(MessageImplementor impl) {
        super(impl);
    }

    //对于加急消息，覆盖父类的方法
    @Override
    public void sendMessage(String message, String toUser) {
        message = "加急!：" + message;
        super.sendMessage(message, toUser);
    }

    //扩展新的功能
    public void other() {
    }
}
```

### 由抽象部分得对象自己创建对应得Implement对象

#### 1.从外部传递参数

```java
package interfaceTest;

public class InterfaceTest02 {
    public static void main(String[] args) {
        AbstartMessage message = new CommonMessage();
        message.sendMessage("信件内容", "Tom");
    }
}

//抽象化角色
abstract class AbstartMessage {

    protect MessageImplementor getImpl(String message) {
        MessageImplementor impl = null;
        if (message == null || message.length() > 100) {
            impl = new MessageSMS();
        } else {
            impl = new MessageEmail();
        }
        return impl;
    }

    public void sendMessage(String message, String toUser) {
        this.getImpl(message).send(message, toUser);
    }
}

//抽象修正角色

//实现化角色
interface MessageImplementor {
    public void send(String message, String toUser);
}

//具体实现角色
//以站内短消息的方式发送
class MessageSMS implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("SMS-[" + message + "]-TO-" + toUser);
    }
}

//以E-mail的方式发送
class MessageEmail implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("Email-[" + message + "]-TO-" + toUser);
    }
}

//扩展抽象的消息接口

//普通消息
class CommonMessage extends AbstartMessage {

    //对于普通消息直接调用父类的，不改变
    @Override
    public void sendMessage(String message, String toUser) {
        super.sendMessage(message, toUser);
    }
}

//加急消息
class UrgentMessage extends AbstartMessage {

    //对于加急消息，覆盖父类的方法
    @Override
    public void sendMessage(String message, String toUser) {
        message = "加急!：" + message;
        super.sendMessage(message, toUser);
    }

    //扩展新的功能
    public void other() {
    }
}
```

```java
package interfaceTest;

public class Interfacetest03 {
    public static void main(String[] args) {
        Salary salary = new Employee();
        salary.sendSalary(5000, "Tom");
        salary = new Boss();
        salary.sendSalary(1000, "King");
        
        //分发给员工-Tom的是银行转账-[5000]
        //分发给股东-King的是现金-[1000]
    }
}

//工资
abstract class Salary {
    Distribution distribution;

    public Distribution getDistribution(int salary) {
        if (salary < 3000) {
            return new Cash();
        } else {
            return new Bank();
        }
    }

    public void sendSalary(int salary, String name) {
        this.getDistribution(salary).distribute(salary, name);
    }
}

class Employee extends Salary {
    @Override
    public void sendSalary(int salary, String name) {
        name = "员工-" + name;
        super.sendSalary(salary, name);
    }
}

class Boss extends Salary {
    @Override
    public void sendSalary(int salary, String name) {
        name = "股东-" + name;
        super.sendSalary(salary, name);
    }
}

//对工资的分配
interface Distribution {
    void distribute(int salary, String name);
}

class Cash implements Distribution {
    @Override
    public void distribute(int salary, String name) {
        System.out.println("分发给" + name + "的是现金-[" + salary + "]");
    }
}

class Bank implements Distribution {
    @Override
    public void distribute(int salary, String name) {
        System.out.println("分发给" + name + "的是银行转账-[" + salary + "]");
    }
}
```

#### 2. 创建默认的Implement对象

```java

```

#### 3.使用工厂模式

```java

```

#### 4.使用IoC/DI的方式

```java

```

### 实现JDBC

## 组合模式 合成模型模式/Composite模式

- 将对象组合成树形结构以表示“整体-部分”的结构层次。




