# JVM

# JVM内存解析

![](vx_images/28475022249164.png =326x)

## 堆

一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，方便执行器执行，堆内存分为三部分：

- Young Generation Space 新生区 Young
- Tenure generation space 养老区 Old
- Permanent Space 永久存储区（规范）（方法区，并不属于堆） Perm

![](vx_images/462591123244300.png =287x)

### 新生区

新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区(Eden space)和幸存者区
(Survifor pace),所有的类都是在伊甸区被new出来的。幸存区有两个：O区（Survivora0 space)和1区(Survivor1 space)。当伊甸园的空间用完时，程序又需要创建对象

JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC(FullGC),进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常'OutOfMemory Error'。

如果出现java.lang.OutOfMemoryError::Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：

1. Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。
2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。

### 永久存储区/方法区(Method Area)

实际而言，方法区(Method Area)和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态变量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开

对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Permanent Gen)”,但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。

常量池(Constant Pool)是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。

- 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class,Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。

- 如果出现java.lang.OutOfMemoryError: PermGen space,说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。
   - Jdk1.6及之前：常量池分配在永久代，1.6在方法区
   - Jdk1.7:有，但已经逐步"去永久代”，1.7在堆
   - Jdk1.8及之后：无，1.8在元空间(方法区内)
   